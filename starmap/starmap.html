<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title id="pageTitle">VGAP Starmap</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 10;
      font-family: sans-serif;
      background-color: #1A1B26; /* background */
      color: #7AA2F7;            /* secondary */
    }

    canvas { border: 1px solid #ccc; background-color: black; }

    input[type="color"] {
      background: none;
      border: none;
      cursor: pointer;
    }

    input[type="range"] {
      margin: 3px;
      accent-color: #7AA2F7;
    }

    button {
      background-color: #7AA2F7;  /* secondary */
      color: #24283B;             /* button-color-foreground */
      border: none;
      padding: 6px 10px;
      margin: 4px;
      border-radius: 4px;
      cursor: pointer;
    }

    button:hover {
      background-color: #8AB2FF; /* primary on hover */
    }

    h1, h2, h3, h4 {
      font-family: 'Orbitron', sans-serif;
      letter-spacing: 0.06em;
      color: #BB9AF7; /* theme primary color */
      margin-top: 0.7em;
      margin-bottom: 0.5em;
      padding-bottom: 0.2em;
    }

    h1 {
      font-size: 2em;
    }

    h2 {
      font-size: 1.75em;
    }

    h3 {
      font-size: 1.5em;
    }

    h4 {
      font-size: 1.25em;
    }

    #tooltip {
      position: absolute;
      background: #24283B;
      border: 1px solid #7AA2F7;
      color: #BB9AF7;
      padding: 6px 10px;
      font-size: 12px;
      font-family: sans-serif;
      pointer-events: none;
      display: none;
      border-left: 6px solid transparent;
      z-index: 10;
      max-width: 300px;
      white-space: normal;
    }

    #mainLayout {
      display: flex;
      align-items: flex-start;
      gap: 20px;
      padding: 20px;
      background-color: #1A1B26; /* background */
    }

    #canvasWrapper {
      max-width: 900px;
      width: 85vw;
      height: 85vh; /* fit most of the viewport */
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #1A1B26; /* match theme background */
    }

    #starmap {
      display: block;
      border: 1px solid #414868; /* panel border */
      background-color: black;
    }

    #sidebar {
      font-family: sans-serif;
      background-color: #414868;  /* panel */
      padding: 8px;
      border-radius: 8px;
      min-width: 250px;
    }

    #playerTable {
      width: 100%;
      border-collapse: collapse;
      background-color: #24283B; /* surface */
      color: #7AA2F7;            /* secondary */
      border-radius: 6px;
    }

    #playerTable th {
      background-color: #414868; /* panel */
      color: #BB9AF7;            /* primary */
      padding: 6px;
      text-align: left;
      border-bottom: 1px solid #1A1B26;
    }

    #playerTable td {
      padding: 6px;
      font-size: 14px;
    }

    #controls {
      padding: 0px 20px;
    }

    #zoom-indicator {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: #a9b1d6; /* foreground from tokyo-night */
      background: rgba(36, 40, 59, 0.8); /* surface with transparency */
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-family: monospace;
      pointer-events: none;
    }

    #bubble {
      background-color: #414868; /* panel */
      padding: 8px;
      margin-bottom: 8px;
    }

    #playerHeader {
      color: #BB9AF7; /* primary */
      margin: 4px;
      font-size: 1.2em;
      cursor: pointer;
    }

    #playerCompressed {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
    }

    .playerBox {
      background-color: #24283B;
      color: #BB9AF7;
      padding: 4px 6px;
      border-radius: 4px;
      font-size: 12px;
      font-family: sans-serif;
      cursor: default;
    }

    #newsList {
      font-family: sans-serif;
      font-size: 12px;
      color: #E0E0E0;
      margin-top: 0.5em;
    }

    .newsBlock {
      padding-left: 0.3em;
    }

    #newsList ul {
      list-style: none;
      margin: 0;
      padding: 0;
    }

    #newsList li {
      padding: 1px 0;
      line-height: 1.3em;
    }

    #newsList li.explosion {
      padding-left: 0.8em;
      color: #FFB86C;
    }
  </style>
</head>
<body>

<div id="tooltip"></div>

<div id="mainLayout">
  <div>
    <div id="canvasWrapper">
      <canvas id="starmap"></canvas>
    </div>
    <div id="controls">
      <label for="turnSlider">Turn: <span id="turnLabel">1</span></label>
      <input type="range" id="turnSlider" min="1" max="1" value="1">

      <button id="rewindButton">‚èÆÔ∏è</button>
      <button id="stepBackButton">‚¨ÖÔ∏è</button>
      <button id="stepForwardButton">‚û°Ô∏è</button>
      <button id="playPauseButton">‚ñ∂Ô∏è</button>
      <div>
        <button id="zoomInButton">üîç+</button>
        <button id="zoomOutButton">üîç‚àí</button>
        <button id="resetViewButton">üîÑ Reset</button>
      </div> 
    </div>
    <div id="zoom-indicator"></div>
  </div>
  <div id="sidebar">
    <div id="bubble">
      <h3 id="mapTitle">Starmap</h3>
    </div>
    <div id="bubble">
      <h4 id="playerHeader">Players</h4>
      <table id="playerTable">
        <tbody></tbody>
      </table>
      <div id="playerCompressed" style="display: none;"></div>
    </div>
    <div id="bubble">
      <h4 id="newsTitle">News</h4>
      <ul id="XXXnewsList"></ul>

      <div id="newsList">
        <div class="newsBlock">
          <ul>
            <li>S10 LARGE DEEP SPACE FREIGHTER (2) ‚ò†Ô∏è vs S75 LOKI CLASS DESTROYER (1)</li>
            <li>S75 LOKI CLASS DESTROYER (1) vs ‚óØ P109 Backinfuture (2) ‚ò†Ô∏è</li>
            <li class="explosion">üí• LARGE DEEP SPACE FREIGHTER</li>
          </ul>
        </div>

        <div class="newsBlock">
          <ul>
            <li>S68 IFL U Can't Touch This (5) ‚ò†Ô∏è vs S65 DWARFSTAR CLASS TRANSPORT (6)</li>
          </ul>
        </div>
      </div>

    </div>
  </div>
</div>



<script>

Promise.all([
  fetch('starmap.json').then(res => res.json()),
  fetch('shiplist.json').then(res => res.json()),
  fetch('messagelist.json').then(res => res.json())
])
  .then(([starmapData, shiplistData, messagelistData]) => {
    window.starmapData = starmapData;
    window.shiplistData = shiplistData;
    window.messagelistData = messagelistData;
    initializeMap();
  })
  .catch(err => {
    console.error("Failed to load data:", err);
  });

const canvas = document.getElementById('starmap');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');
let starmapTree = null;
const shipTrees = {};
const newsTrees = {};
let screenPlanets = [];

let maxTurn = 1;
let currentTurnId = 1;

let isPlaying = false;
let playInterval = null;
let animationFrameId = null;

const animationSettings = {
  framesPerTurn: 30,
  frameDuration: 1000 / 60, // ~60fps
  currentFrame: 0,
  currentTurn: 0
};

let planetOwner = {};
let starbaseSet = new Set();

/* zoom and pan */
const MIN_ZOOM = 0.2;
const MAX_ZOOM = 5.0;

let zoom = 1.0;
let mapWidth = 0;
let mapHeight = 0;
let bounds = {
    left: 0,
    right: 0,
    bottom: 0,
    top: 0
};
let baseScale = 1.0;
let centerOffsetX = 0;
let centerOffsetY = 0;
let offsetX = 0;
let offsetY = 0;
let isDragging = false;
let dragStart = { x: 0, y: 0 };

let tx = null;
let ty = null;
let invTx = null;
let invTy = null;

/* kd-tree for fast search */

class KDNode {
  constructor(point, axis = 0, left = null, right = null) {
    this.point = point;
    this.axis = axis;
    this.left = left;
    this.right = right;
  }
}

function buildKDTree(points, depth = 0) {
  if (!points.length) return null;

  const axis = depth % 2;
  const key = axis === 0 ? "x" : "y";

  points.sort((a, b) => a[key] - b[key]);
  const mid = Math.floor(points.length / 2);

  return new KDNode(
    points[mid],
    axis,
    buildKDTree(points.slice(0, mid), depth + 1),
    buildKDTree(points.slice(mid + 1), depth + 1)
  );
}

function distSq(a, b) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return dx * dx + dy * dy;
}

function nearestKD(node, target, radiusSq = Infinity, best = { point: null, distSq: Infinity }) {
  if (!node) return best;

  const axis = node.axis;
  const key = axis === 0 ? 'x' : 'y';

  const d = distSq(target, node.point);
  if (d < best.distSq && d < radiusSq) {
    best = { point: node.point, distSq: d };
  }

  const diff = target[key] - node.point[key];
  const close = diff < 0 ? node.left : node.right;
  const away = diff < 0 ? node.right : node.left;

  best = nearestKD(close, target, radiusSq, best);

  // Check if we should search the other branch
  if (diff * diff < best.distSq) {
    best = nearestKD(away, target, radiusSq, best);
  }

  return best;
}

function rangeKD(node, target, radiusSq, results = []) {
  if (!node) return results;

  const axis = node.axis;
  const key = axis === 0 ? 'x' : 'y';

  const dx = target.x - node.point.x;
  const dy = target.y - node.point.y;
  const distSq = dx * dx + dy * dy;

  if (distSq <= radiusSq) {
    results.push({ point: node.point, distSq });
  }

  const diff = target[key] - node.point[key];
  const close = diff < 0 ? node.left : node.right;
  const away = diff < 0 ? node.right : node.left;

  // Always check the close side
  rangeKD(close, target, radiusSq, results);

  // Check away side only if hyperplane is within radius
  if (diff * diff <= radiusSq) {
    rangeKD(away, target, radiusSq, results);
  }

  return results;
}

function closestGrouped(results) {
  if (!results.length) return [];

  // Find the minimum distance
  let minDistSq = Infinity;
  for (const r of results) {
    if (r.distSq < minDistSq) minDistSq = r.distSq;
  }

  // Filter all results that are exactly at that distance
  return results.filter(r => r.distSq === minDistSq);
}

function getPlanetOwners(turnIndex) {
  const ownerString = starmapData.planet_owners[turnIndex - 1];
  const owners = {};
  for (let i = 0; i < ownerString.length; i++) {
    const ch = ownerString[i];
    const owner = parseInt(ch, 36);  // base-36 decode
    owners[i] = owner;  // planet ID is index, planet "0" is unused
  }
  return owners;
}


function getShipsForTurn(turn) {
  const raw = shiplistData.shiplist[turn - 1];
  const result = [];
  if (!raw) return result;

  for (const key in raw) {
    const [xStr, yStr] = key.split(",");
    const x = parseInt(xStr, 10);
    const y = parseInt(yStr, 10);

    const values = raw[key];
    for (let i = 0; i < values.length; i += 2) {
      const uid = values[i];
      const ammo = values[i + 1];

      const info = shiplistData.shipinfo[uid];
      if (!info) continue;
      rec = shiplistData.shipdescs[info.shipdesc]
      shipdesc = rec[0]
      bv = rec[1]
      dv = rec[2]
      sv = bv + (dv * 2)
      result.push({
        uid,
        id: info.id,
        name: info.name,
        x,
        y,
        ammo,
        ownerid: info.ownerid,
        desc: shipdesc,
        bv: bv,
        dv: dv,
        sv: sv
      });
    }
  }
  return result;
}

function isStarbase(planetId) {
  return starbaseSet.has(planetId);
}

function getColor(ownerid) {
  const player = starmapData.players.find(p => p.id === ownerid);
  return player ? player.color : "#888888";
}

function updateTurn(turnId) {
  currentTurnId = turnId;
  planetOwner = getPlanetOwners(currentTurnId)
  starbaseSet = new Set(starmapData.starbases[currentTurnId - 1] || []);
  document.getElementById("turnLabel").textContent = turnId;
  drawMap();
  updateNewsPanel(turnId);
}

function scaleRadius(base, zoom, min = 2) {
  max = base * 3;
  return Math.max(min, Math.min(max, base * zoom));
}

function drawCircle(x, y, radius, color) {
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, 2 * Math.PI);
  ctx.fillStyle = color;
  ctx.fill();
}

function drawOpenCircle(x, y, radius, color) {
  const OFFSET = -1
  ctx.beginPath();
  ctx.arc(x + OFFSET, y + OFFSET, radius, 0, 2 * Math.PI);
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.stroke();
}

function drawCross(x, y, size, color) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x - size, y);
  ctx.lineTo(x + size, y);
  ctx.moveTo(x, y - size);
  ctx.lineTo(x, y + size);
  ctx.stroke();
}

function drawRect(x, y, size, color) {
  const width = size * Math.SQRT2;
  const height = size;
  const halfW = width / 2;
  const halfH = height / 2;

  const topLeft = { x: x - halfW, y: y - halfH };
  const topRight = { x: x + halfW, y: y - halfH };
  const bottomRight = { x: x + halfW, y: y + halfH };
  const bottomLeft = { x: x - halfW, y: y + halfH };

  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.strokeRect(topLeft.x, topLeft.y, width, height);

  return { topLeft, topRight, bottomRight, bottomLeft };
}

function drawLeftSlash(corners, color) {
  ctx.beginPath();
  ctx.moveTo(corners.topLeft.x, corners.topLeft.y);
  ctx.lineTo(corners.bottomRight.x, corners.bottomRight.y);
  ctx.strokeStyle = color;
  ctx.stroke();
}

function drawRightSlash(corners, color) {
  ctx.beginPath();
  ctx.moveTo(corners.topRight.x, corners.topRight.y);
  ctx.lineTo(corners.bottomLeft.x, corners.bottomLeft.y);
  ctx.strokeStyle = color;
  ctx.stroke();
}

function drawSlashedRect(x, y, size, color) {
  const corners = drawRect(x, y, size, color);
  drawLeftSlash(corners, color);
}

function drawCrossedRect(x, y, size, color) {
  const corners = drawRect(x, y, size, color);
  drawLeftSlash(corners, color);
  drawRightSlash(corners, color);
}

function drawTriangle(x, y, size, color) {
  const Y_OFFSET = -3
  const base = size * Math.SQRT2;
  const halfBase = base / 2;
  const halfHeight = size / 2;

  ctx.beginPath();
  ctx.moveTo(x, y - halfHeight + Y_OFFSET);                 // Top vertex
  ctx.lineTo(x - halfBase, y + halfHeight + Y_OFFSET);      // Bottom left
  ctx.lineTo(x + halfBase, y + halfHeight + Y_OFFSET);      // Bottom right
  ctx.closePath();

  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.stroke();
}

function updateZoomIndicator() {
  const zoomDisplay = (zoom * 100).toFixed(0) + "%";
  document.getElementById("zoom-indicator").textContent = `Zoom: ${zoomDisplay}`;
}

function getProjectedPositions(x, y) {
  if (starmapData.mapshape !== 1) return [{ x, y, primary: true }];

  const w = starmapData.width + 20;
  const h = starmapData.height + 20;
  const offsets = [
    [-w, -h], [0, -h], [w, -h],
    [-w, 0],  [0, 0],  [w, 0],
    [-w, h],  [0, h],  [w, h]
  ];

  return offsets.map(([dx, dy]) => ({
    x: x + dx,
    y: y + dy,
    primary: dx === 0 && dy === 0
  }));
}

function deproject(mapX, mapY) {
  const w = starmapData.width + 20;
  const h = starmapData.height + 20;

  const dx = Math.trunc(mapX / w) - 1; // center tile is at (w, h)
  const dy = Math.trunc(mapY / h) - 1;
  console.log(`deproject: mapX, mapY: ${mapX},${mapY}, dx,dy: ${dx},${dy} -> ${mapX - dx * w},${mapY - dy * h}`)

  return {
    x: mapX - dx * w,
    y: mapY - dy * h
  };
}

function interpolate(a, b, t) {
  return a + (b - a) * t;
}

function interpolateWrapped(a, b, range, t) {
  let delta = b - a;

  if (Math.abs(delta) > range / 2) {
    // Take the wrapped (shorter) path
    if (delta > 0) {
      b -= range;
    } else {
      b += range;
    }
  }

  return a + (b - a) * t;
}

function drawMap(options = {}) {
  const {
    turn = currentTurnId,
    nextTurn = null,
    t = 0  // t: 0.0‚Äì1.0 interpolation factor between turn and nextTurn
  } = options;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  screenPlanets = [];


  const mapwidth = starmapData.width;
  const magicPadding = 20;
  const trueWidth = mapwidth + magicPadding;
  const trueHeight = starmapData.height + magicPadding;

  bounds = {
    left: trueWidth,
    right: trueWidth * 2,
    bottom: trueHeight,
    top: trueHeight * 2
  };

  mapWidth = bounds.right - bounds.left;
  mapHeight = bounds.top - bounds.bottom;

  baseScale = Math.min(canvas.width / mapWidth, canvas.height / mapHeight);
  const scaled = baseScale * zoom;

  centerOffsetX = (canvas.width - mapWidth * scaled) / 2;
  centerOffsetY = (canvas.height - mapHeight * scaled) / 2;

  tx = function(x) {
    return (x - bounds.left) * scaled + centerOffsetX + offsetX;
  }

  ty = function(y) {
    return (bounds.top - y) * scaled + centerOffsetY + offsetY;
  }

  invTx = function(sx) {
    return ((sx - offsetX - centerOffsetX) / scaled) + bounds.left;
  }

  invTy = function(sy) {
    return (bounds.top - ((sy - offsetY - centerOffsetY) / scaled));
  }

  const planetList = Object.values(starmapData.planets);
  for (const planet of planetList) {
    const x = planet.x;
    const y = planet.y;
    const ownerId = planetOwner[planet.id] || 0;
    const color = getColor(ownerId);

    const positions = getProjectedPositions(x, y);
    for (const position of positions) {
      const sx = Math.trunc(tx(position.x));
      const sy = Math.trunc(ty(position.y));
      drawCircle(sx, sy, scaleRadius(1, zoom), color);

      if (isStarbase(planet.id)) {
        drawCross(sx, sy, scaleRadius(5, zoom), color);
      }
      screenPlanets.push({ id: planet.id, name: planet.name, x: sx, y: sy, trueX: position.x, trueY: position.y });
    }
  }

  const drawnPositions = new Set();
  const shipsA = getShipsForTurn(turn);
  // Sort by sv descending, so we can only draw the highest sv ship at a given location 
  shipsA.sort((a, b) => b.sv - a.sv);
  const shipsB = nextTurn !== null ? getShipsForTurn(nextTurn) || [] : [];

  const shipMapB = new Map(shipsB.map(s => [s.uid, s]));

  for (const shipA of shipsA) {
    const shipB = shipMapB.get(shipA.uid);
    let x = shipA.x;
    let y = shipA.y;

    if (shipB && nextTurn !== null) {
      // Interpolate position
      x = interpolateWrapped(shipA.x, shipB.x, trueWidth, t);
      y = interpolateWrapped(shipA.y, shipB.y, trueHeight, t);

      // Draw partial trail
      const maxTrail = 1.0;
      const trailBack = maxTrail * (1 - t);  // shrinking trail
      const fStart = Math.max(0, t - trailBack);
      const fEnd = t;

      const x0 = tx(interpolateWrapped(shipA.x, shipB.x, trueWidth, fStart));
      const y0 = ty(interpolateWrapped(shipA.y, shipB.y, trueHeight, fStart));
      const x1 = tx(interpolateWrapped(shipA.x, shipB.x, trueWidth, fEnd));
      const y1 = ty(interpolateWrapped(shipA.y, shipB.y, trueHeight, fEnd));

      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(x1, y1);
      ctx.strokeStyle = getColor(shipA.ownerid);
      ctx.lineWidth = 3;
      ctx.setLineDash([1, 4]);  // Dotted trail
      ctx.stroke();
      ctx.setLineDash([]);
    }

    const color = getColor(shipA.ownerid);
    const positions = getProjectedPositions(x, y);
    const sv = shipA.sv;
    for (const { x: px, y: py } of positions) {
      const key = `${px},${py}`;
      if (drawnPositions.has(key)) continue;

      drawnPositions.add(key);
      const sx = tx(px);
      const sy = ty(py);
      const r = scaleRadius(6, zoom);

      // Choose shape by SV thresholds
      if (sv >= 2000) {
        drawCrossedRect(sx, sy, r, color);
      } else if (sv >= 1500) {
        drawSlashedRect(sx, sy, r, color);
      } else if (sv >= 1000) {
        drawRect(sx, sy, r, color);
      } else if (sv >= 500) {
        drawTriangle(sx, sy, r, color);
      } else if (sv >= 250) {
        drawOpenCircle(sx, sy, scaleRadius(4, zoom), color);
      } else {
        drawOpenCircle(sx, sy, scaleRadius(2, zoom), color);
      }
    }
  }

  const borderLeft   = tx(bounds.left + magicPadding);
  const borderBottom = ty(bounds.bottom + magicPadding);
  const borderRight  = tx(bounds.right + magicPadding);
  const borderTop    = ty(bounds.top + magicPadding);

  ctx.strokeStyle = "#444";
  ctx.lineWidth = 1;

  ctx.strokeRect(
    borderLeft,
    borderTop,
    borderRight - borderLeft,
    borderBottom - borderTop
  );
  
  updateZoomIndicator()
}

canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const mapX = invTx(mx);
  const mapY = invTy(my);
  let hoverRadius = Math.min(Math.max(50, 25 * zoom), 100);
  let mousePoint = { x: mapX, y: mapY };

  const planetResult = nearestKD(starmapTree, mousePoint, hoverRadius);
  const planet = planetResult.point;

  const turn = parseInt(document.getElementById("turnSlider").value);
  const shipTree = shipTrees[turn];
  const shipMatches = closestGrouped(shipTree ? rangeKD(shipTree, mousePoint, hoverRadius) : []);

  if (planet || shipMatches.length > 0) {
    let html = "";

    // Ships
    shipMatches.sort((a, b) => a.point.sv - b.point.sv);
    for (const match of shipMatches) {
      const ship = match.point;
      const player = starmapData.players.find(p => p.id === ship.ownerid);
      const color = player ? player.color : "#888";
      const desc = ship.desc;
      const ammoText = ship.bv > 0 ? `/${ship.ammo}` : "";
      html += `<div style="color: ${color};"> ‚ùØ S${ship.id} ${ship.name} - ${desc}${ammoText} [${ship.uid}]</div>`;
    }

    // Planet
    if (planet) {
      const ownerId = planetOwner[planet.id] || 0;
      const player = starmapData.players.find(p => p.id === ownerId);
      const ownerName = player ? player.name : "Unowned";
      const ownerColor = player ? player.color : "#888";
      const star = isStarbase(planet.id) ? "‚®Å" : "";
      html += `<div style="margin-top: 4px; color: ${ownerColor};">${star} P${planet.id} ${planet.name} (${ownerName}) [${planet.x},${planet.y}]</div>`;
      tooltip.style.borderLeftColor = ownerColor;
    } else {
      tooltip.style.borderLeftColor = "#666";
    }

    tooltip.innerHTML = html;
    tooltip.style.left = `${e.pageX + 10}px`;
    tooltip.style.top = `${e.pageY + 10}px`;
    tooltip.style.display = 'block';
  } else {
    tooltip.style.display = 'none';
  }
});

canvas.addEventListener('mouseleave', () => {
  tooltip.style.display = 'none';
});

function resizeCanvasToMapAspect() {
  const wrapper = document.getElementById("canvasWrapper");
  const canvas = document.getElementById("starmap");

  const mapWidth = starmapData.width;
  const mapHeight = starmapData.height;
  const aspectRatio = mapWidth / mapHeight;

  // Available space
  const maxWidth = Math.min(wrapper.clientWidth, 900); // keep canvas modest
  const maxHeight = wrapper.clientHeight;

  // Fit while preserving aspect ratio
  if (maxWidth / maxHeight > aspectRatio) {
    canvas.height = maxHeight;
    canvas.width = Math.floor(maxHeight * aspectRatio);
  } else {
    canvas.width = maxWidth;
    canvas.height = Math.floor(maxWidth / aspectRatio);
  }
}

window.addEventListener("resize", () => {
  resizeCanvasToMapAspect();
  drawMap();
});

function initializeMap() {
  // build kdtree for planets
  starmapTree = buildKDTree(starmapData.planets);

  // build kdtree for ships for each turn
  for (let turn = 0; turn < shiplistData.shiplist.length; turn++) {
    shipTrees[turn] = buildKDTree(getShipsForTurn(turn));
  }

  // build kdtree for news for each turn
  const news = newsreader.parse(messagelistData.messagelist);
  for (let turn = 0; turn < news.length; turn++) {
    newsTrees[turn] = buildKDTree(news[turn]);
  }

  document.getElementById("pageTitle").textContent = starmapData.title || "Starmap";
  document.getElementById("mapTitle").textContent = starmapData.title || "Starmap";

  const tableBody = document.querySelector('#playerTable tbody');
  for (const player of starmapData.players) {
    const row = document.createElement('tr');
    row.innerHTML = `
      <td>${player.name}</td>
      <td>${player.race}</td>
      <td><input type="color" value="${player.color}" data-player="${player.id}"></td>
    `;
    tableBody.appendChild(row);
  }

  const compressedContainer = document.getElementById('playerCompressed');
  compressedContainer.innerHTML = '';
  for (const player of starmapData.players) {
    const box = document.createElement('div');
    box.className = 'playerBox';
    const secondWord = player.race.split(' ')[1] || player.race;
    box.textContent = secondWord.slice(0, 2);
    box.title = player.name;
    box.style.borderLeft = `6px solid ${player.color}`;
    compressedContainer.appendChild(box);
  }

  tableBody.addEventListener('input', (e) => {
    if (e.target.type === 'color') {
      const playerId = parseInt(e.target.dataset.player, 10);
      const player = starmapData.players.find(p => p.id === playerId);
      if (player) {
        player.color = e.target.value;
        drawMap();
      }
    }
  });

  document.getElementById('playerHeader').addEventListener('click', () => {
    const table = document.getElementById('playerTable');
    const compressed = document.getElementById('playerCompressed');
    const isTableVisible = table.style.display !== 'none';

    table.style.display = isTableVisible ? 'none' : '';
    compressed.style.display = isTableVisible ? '' : 'none';
  });

  const slider = document.getElementById("turnSlider");
  maxTurn = starmapData.turns;
  slider.max = maxTurn;
  slider.value = 1;
  slider.addEventListener("input", () => {
    updateTurn(parseInt(slider.value));
  });

  document.getElementById("playPauseButton").addEventListener("click", togglePlayPause);
  document.getElementById("rewindButton").addEventListener("click", rewind);
  document.getElementById("stepBackButton").addEventListener("click", () => {
    let current = parseInt(slider.value);
    if (current > 1) {
      slider.value = current - 1;
      updateTurn(parseInt(slider.value));
    }
  });

  document.getElementById("stepForwardButton").addEventListener("click", () => {
    let current = parseInt(slider.value);
    if (current < maxTurn) {
      slider.value = current + 1;
      updateTurn(parseInt(slider.value));
    }
  });

  document.getElementById("zoomInButton").addEventListener("click", () => {
    zoom *= 1.25;
    drawMap();
  });

  document.getElementById("zoomOutButton").addEventListener("click", () => {
    zoom /= 1.25;
    drawMap();
  });

  document.getElementById("resetViewButton").addEventListener("click", () => {
    zoom = 1.0;
    offsetX = 0;
    offsetY = 0;
    drawMap();
  });

  resizeCanvasToMapAspect();
  updateTurn(1);
}

function animateStep() {
  const {
    currentTurn,
    currentFrame,
    framesPerTurn
  } = animationSettings;

  const nextTurn = currentTurn + 1;
  const slider = document.getElementById("turnSlider");
  const max = parseInt(slider.max);

  const t = currentFrame / framesPerTurn;
  drawMap({ turn: currentTurn, nextTurn, t });

  animationSettings.currentFrame++;

  if (animationSettings.currentFrame < framesPerTurn) {
    animationFrameId = requestAnimationFrame(animateStep);
  } else {
    animationSettings.currentTurn++;
    slider.value = animationSettings.currentTurn;
    updateTurn(animationSettings.currentTurn); // update other UI

    if (animationSettings.currentTurn >= max) {
      togglePlayPause(); // Stop at last turn
    } else {
      animationSettings.currentFrame = 0;
      animationFrameId = requestAnimationFrame(animateStep);
    }
  }
}

function togglePlayPause() {
  const button = document.getElementById("playPauseButton");

  if (isPlaying) {
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
    isPlaying = false;
    button.textContent = "‚ñ∂Ô∏è";
  } else {
    isPlaying = true;
    button.textContent = "‚è∏Ô∏è";

    const slider = document.getElementById("turnSlider");
    animationSettings.currentTurn = parseInt(slider.value);
    animationSettings.currentFrame = 0;

    requestAnimationFrame(animateStep);
  }
}

function rewind() {
  const slider = document.getElementById("turnSlider");
  slider.value = 1;
  updateTurn(1);
  if (isPlaying) togglePlayPause(); // Stop playback if active
}

canvas.addEventListener("mousedown", (e) => {
  isDragging = true;
  dragStart = { x: e.clientX, y: e.clientY };
});

canvas.addEventListener("mouseup", () => {
  isDragging = false;
});

canvas.addEventListener("mouseleave", () => {
  isDragging = false;
});

canvas.addEventListener("mousemove", (e) => {
  if (isDragging) {
    const dx = e.clientX - dragStart.x;
    const dy = e.clientY - dragStart.y;
    dragStart = { x: e.clientX, y: e.clientY };
    offsetX += dx;
    offsetY += dy;
    drawMap();
  }
});

canvas.addEventListener("wheel", (e) => {
  event.preventDefault(); // prevent page scroll

  const rect = canvas.getBoundingClientRect();
  const mx = event.clientX - rect.left;
  const my = event.clientY - rect.top;

  // World coords before zoom
  const mapX = (mx - centerOffsetX - offsetX) / (baseScale * zoom) + bounds.left;
  const mapY = bounds.top - (my - centerOffsetY - offsetY) / (baseScale * zoom);

  const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1;
  zoom *= zoomFactor;

  // Recompute scale & center offsets
  const newScaled = baseScale * zoom;
  const newCenterOffsetX = (canvas.width - mapWidth * newScaled) / 2;
  const newCenterOffsetY = (canvas.height - mapHeight * newScaled) / 2;

  // Adjust pan so zoom focuses on mouse
  offsetX = mx - (mapX - bounds.left) * newScaled - newCenterOffsetX;
  offsetY = my - (bounds.top - mapY) * newScaled - newCenterOffsetY;

  centerOffsetX = newCenterOffsetX;
  centerOffsetY = newCenterOffsetY;

  drawMap();
}, { passive: false }); // notify browser that native scrolling will be disabled

function centerMapOn(x, y) {
  const screenCenterX = canvas.width / 2;
  const screenCenterY = canvas.height / 2;
  const scaled = baseScale * zoom;

  offsetX = screenCenterX - (x - bounds.left) * scaled - centerOffsetX;
  offsetY = screenCenterY - (bounds.top - y) * scaled - centerOffsetY;

  drawMap();
}

canvas.addEventListener("dblclick", (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const { x, y } = deproject(invTx(mx), invTy(my));
  centerMapOn(x, y);
});

const newsreader = {
  BATTLE: 100,
  EXPLOSION: 101,

  parse: function(newsRecords) {
    const result = [];

    for (const entry of newsRecords) {
      const turnResult = [];

      for (const key in entry) {
        const [x, y] = key.split(',').map(Number);
        const messages = entry[key];
        const newsItems = [];

        for (const record of messages) {
          const [type, ...rest] = record;

          if (type === this.BATTLE) {
            const [btype, leftId, rightId, leftName, rightName, leftOwner, rightOwner, leftSurvives, rightSurvives] = rest;
            newsItems.push({
              type: 'BATTLE',
              btype,
              leftId, rightId,
              leftName, rightName,
              leftOwner, rightOwner,
              leftSurvives, rightSurvives
            });
          } else if (type === this.EXPLOSION) {
            const [name] = rest;
            newsItems.push({
              type: 'EXPLOSION',
              name
            });
          } else {
            console.warn("Unknown news type:", type);
          }
        }

        turnResult.push({ x, y, news: newsItems });
      }

      result.push(turnResult);
    }

    return result;
  }
};

function formatNewsItem(newsItem) {
  const li = document.createElement("li");

  if (newsItem.type === "BATTLE") {
    const l = newsItem.leftSurvives ? "" : "‚ùå";
    const r = newsItem.rightSurvives ? "" : "‚ùå";
    const p = newsItem.btype === 0 ? "S" : newsItem.btype === 1 ? "‚óØ P" : "‚®Å P";

    const leftColor = getColor(newsItem.leftOwner);
    const rightColor = getColor(newsItem.rightOwner);

    li.innerHTML = `
      <span style="color: ${leftColor}">S${newsItem.leftId} ${newsItem.leftName} (${newsItem.leftOwner}) ${l}</span>
      <span> vs </span>
      <span style="color: ${rightColor}">${p}${newsItem.rightId} ${newsItem.rightName} (${newsItem.rightOwner}) ${r}</span>
    `;

  } else if (newsItem.type === "EXPLOSION") {
    li.classList.add("explosion");
    li.textContent = `üí• ${newsItem.name}`;
  } else {
    li.textContent = "Unknown news type";
  }

  return li;
}

function updateNewsPanel(turnId) {
  const list = document.getElementById("newsList");
  list.innerHTML = ""; // Clear previous entries

  const center = {
    x: invTx(canvas.width / 2),
    y: invTy(canvas.height / 2)
  };

  const visibleNews = rangeKD(newsTrees[turnId - 1], center, 1e12).map(r => r.point);

  for (const item of visibleNews) {
    const ul = document.createElement("ul");
    ul.classList.add("newsBlock");
    // Attach recenter handler to the whole block
    ul.addEventListener("click", () => {
      centerMapOn(item.x, item.y);
    });

    for (const newsItem of item.news) {
      const li = formatNewsItem(newsItem);
      ul.appendChild(li);
    }

    list.appendChild(ul);
  }
}

</script>

</body>
</html>
