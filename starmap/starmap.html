<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title id="pageTitle">VGAP Starmap</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 10;
      font-family: sans-serif;
      background-color: #1A1B26; /* background */
      color: #7AA2F7;            /* secondary */
    }

    canvas { border: 1px solid #ccc; background-color: black; }

    input[type="color"] {
      background: none;
      border: none;
      cursor: pointer;
    }

    input[type="range"] {
      margin: 3px;
      accent-color: #7AA2F7;
    }

    button {
      background-color: #7AA2F7;  /* secondary */
      color: #24283B;             /* button-color-foreground */
      border: none;
      padding: 6px 10px;
      margin: 4px;
      border-radius: 4px;
      cursor: pointer;
    }

    button:hover {
      background-color: #8AB2FF; /* primary on hover */
    }

    #tooltip {
      position: absolute;
      background: #24283B;       /* surface */
      border: 1px solid #7AA2F7; /* secondary */
      color: #BB9AF7;            /* primary */
      padding: 4px 8px;
      font-size: 12px;
      font-family: sans-serif;
      white-space: nowrap;
      pointer-events: none;
      display: none;
      border-left: 6px solid transparent;
      z-index: 10;
    }    

    #mapTitle {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.5em;
      letter-spacing: 0.05em;
      color: #BB9AF7; /* primary */
      margin-top: 0.5em;
    }

    #mainLayout {
      display: flex;
      align-items: flex-start;
      gap: 20px;
      padding: 20px;
      background-color: #1A1B26; /* background */
    }

    #canvasWrapper {
      max-width: 900px;
      width: 85vw;
      height: 85vh; /* fit most of the viewport */
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #1A1B26; /* match theme background */
    }

    #starmap {
      display: block;
      border: 1px solid #414868; /* panel border */
      background-color: black;
    }

    #sidebar {
      font-family: sans-serif;
      background-color: #414868;  /* panel */
      padding: 16px;
      border-radius: 8px;
      min-width: 250px;
    }

    #playerTable {
      width: 100%;
      border-collapse: collapse;
      background-color: #24283B; /* surface */
      color: #7AA2F7;            /* secondary */
    }

    #playerTable th {
      background-color: #414868; /* panel */
      color: #BB9AF7;            /* primary */
      padding: 6px;
      text-align: left;
      border-bottom: 1px solid #1A1B26;
    }

    #playerTable td {
      padding: 6px;
      border-top: 1px solid #1A1B26;
      font-size: 14px;
    }

    #controls {
      padding: 0px 20px;
    }

    #zoom-indicator {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: #a9b1d6; /* foreground from tokyo-night */
      background: rgba(36, 40, 59, 0.8); /* surface with transparency */
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-family: monospace;
      pointer-events: none;
    }
  </style>
</head>
<body>

<div id="tooltip"></div>

<div id="mainLayout">
  <div id="canvasWrapper">
    <canvas id="starmap"></canvas>
  </div>
  <div id="zoom-indicator"></div>

  <div id="sidebar">
    <h3 id="mapTitle">Starmap</h3>
    <table id="playerTable">
      <tbody></tbody>
    </table>
  </div>
</div>

<div id="controls">
  <label for="turnSlider">Turn: <span id="turnLabel">1</span></label>
  <input type="range" id="turnSlider" min="1" max="1" value="1">

  <button id="rewindButton">‚èÆÔ∏è</button>
  <button id="stepBackButton">‚¨ÖÔ∏è</button>
  <button id="stepForwardButton">‚û°Ô∏è</button>
  <button id="playPauseButton">‚ñ∂Ô∏è</button>
  <div>
    <button id="zoomInButton">üîç+</button>
    <button id="zoomOutButton">üîç‚àí</button>
    <button id="resetViewButton">üîÑ Reset</button>
  </div> 
</div>

<script>

Promise.all([
  fetch('starmap.json').then(res => res.json()),
  fetch('shiplist.json').then(res => res.json())
])
  .then(([starmapData, shiplistData]) => {
    window.starmapData = starmapData;
    window.shiplistData = shiplistData.shiplist;
    initializeMap();
  })
  .catch(err => {
    console.error("Failed to load data:", err);
  });

const canvas = document.getElementById('starmap');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');
let starmapTree = null;
let shiplistTree = {};
let screenPlanets = [];

let currentTurnId = "1";
let isPlaying = false;
let playInterval = null;

let planetOwner = {};
let starbaseOwner = {};

/* zoom and pan */
const MIN_ZOOM = 0.2;
const MAX_ZOOM = 5.0;

let zoom = 1.0;
let mapWidth = 0;
let mapHeight = 0;
let bounds = {
    left: 0,
    right: 0,
    bottom: 0,
    top: 0
};
let baseScale = 1.0;
let centerOffsetX = 0;
let centerOffsetY = 0;
let offsetX = 0;
let offsetY = 0;
let isDragging = false;
let dragStart = { x: 0, y: 0 };

let tx = null;
let ty = null;
let invTx = null;
let invTy = null;

/* kd-tree for fast search */

class KDNode {
  constructor(point, axis = 0, left = null, right = null) {
    this.point = point;
    this.axis = axis;
    this.left = left;
    this.right = right;
  }
}

function buildKDTree(points, depth = 0) {
  if (!points.length) return null;

  const axis = depth % 2;
  const key = axis === 0 ? "x" : "y";

  points.sort((a, b) => a[key] - b[key]);
  const mid = Math.floor(points.length / 2);

  return new KDNode(
    points[mid],
    axis,
    buildKDTree(points.slice(0, mid), depth + 1),
    buildKDTree(points.slice(mid + 1), depth + 1)
  );
}

function distSq(a, b) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return dx * dx + dy * dy;
}

function nearestKD(node, target, radiusSq = Infinity, best = { point: null, distSq: Infinity }) {
  if (!node) return best;

  const axis = node.axis;
  const key = axis === 0 ? 'x' : 'y';

  const d = distSq(target, node.point);
  if (d < best.distSq && d < radiusSq) {
    best = { point: node.point, distSq: d };
  }

  const diff = target[key] - node.point[key];
  const close = diff < 0 ? node.left : node.right;
  const away = diff < 0 ? node.right : node.left;

  best = nearestKD(close, target, radiusSq, best);

  // Check if we should search the other branch
  if (diff * diff < best.distSq) {
    best = nearestKD(away, target, radiusSq, best);
  }

  return best;
}

function getColor(ownerid) {
  const player = starmapData.players.find(p => p.id === ownerid);
  return player ? player.color : "#888888";
}

function updateTurn(turnId) {
  currentTurnId = turnId;
  const turn = starmapData.turns[turnId];
  planetOwner = turn.planet_owner || {};
  starbaseOwner = turn.starbase_owner || {};
  document.getElementById("turnLabel").textContent = turnId;
  drawMap();
}

function scaleRadius(base, zoom, min = 2) {
  max = base * 3;
  return Math.max(min, Math.min(max, base * zoom));
}

function drawCircle(x, y, radius, color) {
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, 2 * Math.PI);
  ctx.fillStyle = color;
  ctx.fill();
}

function drawOpenCircle(x, y, radius, color) {
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, 2 * Math.PI);
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.stroke();
}

function drawCross(x, y, size, color) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x - size, y);
  ctx.lineTo(x + size, y);
  ctx.moveTo(x, y - size);
  ctx.lineTo(x, y + size);
  ctx.stroke();
}

function updateZoomIndicator() {
  const zoomDisplay = (zoom * 100).toFixed(0) + "%";
  document.getElementById("zoom-indicator").textContent = `Zoom: ${zoomDisplay}`;
}

function getProjectedPositions(x, y) {
  if (starmapData.mapshape !== 1) return [{ x, y, primary: true }];

  const w = starmapData.width + 20;
  const h = starmapData.height + 20;
  const offsets = [
    [-w, -h], [0, -h], [w, -h],
    [-w, 0],  [0, 0],  [w, 0],
    [-w, h],  [0, h],  [w, h]
  ];

  return offsets.map(([dx, dy]) => ({
    x: x + dx,
    y: y + dy,
    primary: dx === 0 && dy === 0
  }));
}

function drawMap() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  screenPlanets = [];

  const mapwidth = starmapData.width;
  const magicPadding = 20;
  const trueWidth = mapwidth + magicPadding;
  const trueHeight = starmapData.height + magicPadding;

  bounds = {
    left: trueWidth,
    right: trueWidth * 2,
    bottom: trueHeight,
    top: trueHeight * 2
  };

  mapWidth = bounds.right - bounds.left;
  mapHeight = bounds.top - bounds.bottom;

  baseScale = Math.min(canvas.width / mapWidth, canvas.height / mapHeight);
  const scaled = baseScale * zoom;

  centerOffsetX = (canvas.width - mapWidth * scaled) / 2;
  centerOffsetY = (canvas.height - mapHeight * scaled) / 2;

  tx = function(x) {
    return (x - bounds.left) * scaled + centerOffsetX + offsetX;
  }

  ty = function(y) {
    return (bounds.top - y) * scaled + centerOffsetY + offsetY;
  }

  invTx = function(sx) {
    return ((sx - offsetX - centerOffsetX) / scaled) + bounds.left;
  }

  invTy = function(sy) {
    return (bounds.top - ((sy - offsetY - centerOffsetY) / scaled));
  }

  const planetList = Object.values(starmapData.planets);
  for (const planet of planetList) {
    const x = planet.x;
    const y = planet.y;
    const ownerId = planetOwner[planet.id] || 0;
    const color = getColor(ownerId);

    const positions = getProjectedPositions(x, y);
    for (const position of positions) {
      const sx = Math.trunc(tx(position.x));
      const sy = Math.trunc(ty(position.y));
      drawCircle(sx, sy, scaleRadius(1, zoom), color);

      if (starbaseOwner[planet.id]) {
        drawCross(sx, sy, scaleRadius(5, zoom), color);
      }
      screenPlanets.push({ id: planet.id, name: planet.name, x: sx, y: sy, trueX: position.x, trueY: position.y });
    }
  }

  const slider = document.getElementById("turnSlider");
  let currentTurn = slider.value;
  const ships = shiplistData[currentTurn] || {};
  for (const ship of Object.values(ships)) {
    const positions = getProjectedPositions(ship.x, ship.y);
    const color = getColor(ship.ownerid);

    for (const { x, y } of positions) {
      const sx = tx(x);
      const sy = ty(y);
      drawOpenCircle(sx, sy, scaleRadius(3, zoom), color);
    }
  }

  const borderLeft   = tx(bounds.left + magicPadding);
  const borderBottom = ty(bounds.bottom + magicPadding);
  const borderRight  = tx(bounds.right + magicPadding);
  const borderTop    = ty(bounds.top + magicPadding);

  ctx.strokeStyle = "#444";
  ctx.lineWidth = 1;

  ctx.strokeRect(
    borderLeft,
    borderTop,
    borderRight - borderLeft,
    borderBottom - borderTop
  );
  
  updateZoomIndicator()
}


canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const mapX = invTx(mx);
  const mapY = invTy(my);

  const hoverRadius = Math.max(50, 25 * zoom);
  const mousePoint = { x: mapX, y: mapY };
  const result = nearestKD(starmapTree, mousePoint, hoverRadius);
  const found = result.point;

  if (found) {
    const ownerId = planetOwner[found.id] || 0;
    const player = starmapData.players.find(p => p.id === ownerId);
    const ownerName = player ? player.name : "Unowned";
    const ownerColor = player ? player.color : "#888";

    tooltip.textContent = `P${found.id} ${found.name} (${ownerName})`;
    tooltip.style.left = `${e.pageX + 10}px`;
    tooltip.style.top = `${e.pageY + 10}px`;
    tooltip.style.display = 'block';
    tooltip.style.borderLeftColor = ownerColor;
  } else {
    tooltip.style.display = 'none';
  }
});

canvas.addEventListener('mouseleave', () => {
  tooltip.style.display = 'none';
});

function resizeCanvasToMapAspect() {
  const wrapper = document.getElementById("canvasWrapper");
  const canvas = document.getElementById("starmap");

  const mapWidth = starmapData.width;
  const mapHeight = starmapData.height;
  const aspectRatio = mapWidth / mapHeight;

  // Available space
  const maxWidth = Math.min(wrapper.clientWidth, 900); // keep canvas modest
  const maxHeight = wrapper.clientHeight;

  // Fit while preserving aspect ratio
  if (maxWidth / maxHeight > aspectRatio) {
    canvas.height = maxHeight;
    canvas.width = Math.floor(maxHeight * aspectRatio);
  } else {
    canvas.width = maxWidth;
    canvas.height = Math.floor(maxWidth / aspectRatio);
  }
}

window.addEventListener("resize", () => {
  resizeCanvasToMapAspect();
  drawMap();
});

function initializeMap() {
  starmapTree = buildKDTree(starmapData.planets);
  document.getElementById("pageTitle").textContent = starmapData.title || "Starmap";
  document.getElementById("mapTitle").textContent = starmapData.title || "Starmap";

  const tableBody = document.querySelector('#playerTable tbody');
  for (const player of starmapData.players) {
    const row = document.createElement('tr');
    row.innerHTML = `
      <td>${player.name}</td>
      <td>${player.race}</td>
      <td><input type="color" value="${player.color}" data-player="${player.id}"></td>
    `;
    tableBody.appendChild(row);
  }

  tableBody.addEventListener('input', (e) => {
    if (e.target.type === 'color') {
      const playerId = parseInt(e.target.dataset.player, 10);
      const player = starmapData.players.find(p => p.id === playerId);
      if (player) {
        player.color = e.target.value;
        drawMap();
      }
    }
  });

  const slider = document.getElementById("turnSlider");
  const maxTurn = Math.max(...Object.keys(starmapData.turns).map(Number));
  slider.max = maxTurn;
  slider.value = 1;

  slider.addEventListener("input", () => {
    updateTurn(slider.value);
  });

  document.getElementById("playPauseButton").addEventListener("click", togglePlayPause);
  document.getElementById("rewindButton").addEventListener("click", rewind);
  document.getElementById("stepBackButton").addEventListener("click", () => {
    let current = parseInt(slider.value);
    if (current > 1) {
      slider.value = current - 1;
      updateTurn(slider.value);
    }
  });

  document.getElementById("stepForwardButton").addEventListener("click", () => {
    let current = parseInt(slider.value);
    if (current < maxTurn) {
      slider.value = current + 1;
      updateTurn(slider.value);
    }
  });

  document.getElementById("zoomInButton").addEventListener("click", () => {
    zoom *= 1.25;
    drawMap();
  });

  document.getElementById("zoomOutButton").addEventListener("click", () => {
    zoom /= 1.25;
    drawMap();
  });

  document.getElementById("resetViewButton").addEventListener("click", () => {
    zoom = 1.0;
    offsetX = 0;
    offsetY = 0;
    drawMap();
  });

  resizeCanvasToMapAspect();
  updateTurn("1");
}

function togglePlayPause() {
  const button = document.getElementById("playPauseButton");

  if (isPlaying) {
    clearInterval(playInterval);
    playInterval = null;
    button.textContent = "‚ñ∂Ô∏è";
    isPlaying = false;
  } else {
    isPlaying = true;
    button.textContent = "‚è∏Ô∏è";
    playInterval = setInterval(() => {
      const slider = document.getElementById("turnSlider");
      let current = parseInt(slider.value);
      const max = parseInt(slider.max);
      if (current < max) {
        slider.value = current + 1;
        updateTurn(slider.value);
      } else {
        togglePlayPause(); // Stop at last turn
      }
    }, 800); // 800 ms per turn
  }
}

function rewind() {
  const slider = document.getElementById("turnSlider");
  slider.value = 1;
  updateTurn("1");
  if (isPlaying) togglePlayPause(); // Stop playback if active
}

canvas.addEventListener("mousedown", (e) => {
  isDragging = true;
  dragStart = { x: e.clientX, y: e.clientY };
});

canvas.addEventListener("mouseup", () => {
  isDragging = false;
});

canvas.addEventListener("mouseleave", () => {
  isDragging = false;
});

canvas.addEventListener("mousemove", (e) => {
  if (isDragging) {
    const dx = e.clientX - dragStart.x;
    const dy = e.clientY - dragStart.y;
    dragStart = { x: e.clientX, y: e.clientY };
    offsetX += dx;
    offsetY += dy;
    drawMap();
  }
});

canvas.addEventListener("wheel", (e) => {
  event.preventDefault(); // prevent page scroll

  const rect = canvas.getBoundingClientRect();
  const mx = event.clientX - rect.left;
  const my = event.clientY - rect.top;

  // World coords before zoom
  const mapX = (mx - centerOffsetX - offsetX) / (baseScale * zoom) + bounds.left;
  const mapY = bounds.top - (my - centerOffsetY - offsetY) / (baseScale * zoom);

  const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1;
  zoom *= zoomFactor;

  // Recompute scale & center offsets
  const newScaled = baseScale * zoom;
  const newCenterOffsetX = (canvas.width - mapWidth * newScaled) / 2;
  const newCenterOffsetY = (canvas.height - mapHeight * newScaled) / 2;

  // Adjust pan so zoom focuses on mouse
  offsetX = mx - (mapX - bounds.left) * newScaled - newCenterOffsetX;
  offsetY = my - (bounds.top - mapY) * newScaled - newCenterOffsetY;

  centerOffsetX = newCenterOffsetX;
  centerOffsetY = newCenterOffsetY;

  drawMap();
}, { passive: false }); // notify browser that native scrolling will be disabled

</script>

</body>
</html>
