<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title id="pageTitle">VGAP Starmap</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap" rel="stylesheet">
  <style>

:root {
  /* Colours */
  --color-bg:        #1A1B26;
  --color-secondary: #7AA2F7;
  --color-primary:   #BB9AF7;
  --color-panel:     #414868;
  --color-surface:   #24283B;
  --color-hover:     #8AB2FF;
  --color-zoom-text: #a9b1d6;
  --color-explosion: #FFB86C;

  /* Fonts */
  --font-main:     sans-serif;
  --font-display:  'Orbitron', sans-serif;

  /* Spacing */
  --sp-sm: 4px;
  --sp-md: 6px;
  --sp-lg: 8px;
}

*,
*::before,
*::after {
  box-sizing: border-box;
}

body {
  margin: 10px;
  font-family: var(--font-main);
  background: var(--color-bg);
  color: var(--color-secondary);
}

canvas {
  display: block;
  border: 1px solid #ccc;
  background: #000;
}

input[type="color"],
button {
  border: none;
  cursor: pointer;
}

input[type="color"] {
  background: none;
}

input[type="range"] {
  margin: 3px;
  accent-color: var(--color-secondary);
}

button {
  background: var(--color-secondary);
  color: #24283B;
  padding: var(--sp-md) var(--sp-lg);
  margin: var(--sp-md);
  border-radius: 4px;
  transition: background 0.2s;
}
button:hover {
  background: var(--color-hover);
}

/* Headings */
h1, h2, h3, h4 {
  font-family: var(--font-display);
  letter-spacing: 0.06em;
  color: var(--color-primary);
  margin: 0.7em 0 0.5em;
  padding-bottom: 0.2em;
}
h1 { font-size: 2rem; }
h2 { font-size: 1.75rem; }
h3 { font-size: 1.5rem; }
h4 { font-size: 1.25rem; }

/* Tooltip */
#tooltip {
  position: absolute;
  display: none;
  pointer-events: none;
  background: var(--color-surface);
  border: 1px solid var(--color-secondary);
  border-left: 6px solid transparent;
  color: var(--color-primary);
  padding: var(--sp-md) var(--sp-lg);
  font-family: var(--font-main);
  font-size: 12px;
  max-width: 300px;
  white-space: normal;
  z-index: 10;
}

/* Layout */
#mainLayout {
  display: flex;
  align-items: flex-start;
  gap: 20px;
  padding: 20px;
  background: var(--color-bg);
}

#canvasWrapper {
  display: flex;
  justify-content: center;
  align-items: center;
  width: 85vw;
  height: 85vh;
  max-width: 900px;
  background: var(--color-bg);
}

/* Starmap */
#starmap {
  border: 1px solid var(--color-panel);
  background: #000;
}

/* InfoBox */

#infoBox {
  position: absolute;
  top: 8px;
  right: 23px;
  background: rgba(22,22,22,0.8);
  color: #ccc;
  padding: 4px 6px;
  border-radius: 3px;
  font-size: 0.8em;
  pointer-events: none;
  border: 1px ridge #666;
  z-index: 1000;
  max-width: 200px;
  line-height: 1.2;
}

.infoBoxCanvasWrapper {
  padding: 4px 6px;
  justify-content: center;
  align-items: center;
}

/* Sidebar */
#sidebar {
  min-width: 250px;
  padding: var(--sp-lg);
  background: var(--color-panel);
  border-radius: 8px;
  font-family: var(--font-main);
}

/* Player table */
#playerTable {
  width: 100%;
  border-collapse: collapse;
  background: var(--color-surface);
  color: var(--color-secondary);
  border-radius: 6px;
  overflow: hidden;
}
#playerTable th,
#playerTable td {
  padding: var(--sp-md);
}
#playerTable th {
  background: var(--color-panel);
  color: var(--color-primary);
  text-align: left;
  border-bottom: 1px solid var(--color-bg);
}
#playerTable td {
  font-size: 14px;
}

/* Controls */
#controls {
  padding: 0 20px;
}

/* Zoom indicator */
#zoom-indicator {
  position: absolute;
  bottom: 10px;
  right: 10px;
  background: rgba(36, 40, 59, 0.8);
  color: var(--color-zoom-text);
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  font-family: monospace;
  pointer-events: none;
}

/* Bubbles (sidebar sections) */
#bubble {
  background: var(--color-panel);
  padding: var(--sp-lg);
  margin-bottom: var(--sp-lg);
}

/* Player header toggle */
#playerHeader {
  font-size: 1.2rem;
  color: var(--color-primary);
  margin: var(--sp-sm) 0;
  cursor: pointer;
}

/* Compressed player colours */
#playerCompressed {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-top: 8px;
}
.playerBox {
  background: var(--color-surface);
  color: var(--color-primary);
  padding: 4px 6px;
  border-radius: 4px;
  font-size: 12px;
  font-family: var(--font-main);
}

/* News list */
#newsList {
  font-family: var(--font-main);
  font-size: 12px;
  color: #E0E0E0;
  margin-top: 0.5em;
}
#newsList ul {
  list-style: none;
  margin: 0;
  padding: 0.3em 0.1em 0.5em 0.1em;
  border-top: 1px solid #8882;
}
#newsList li {
  padding:  0.1em 0.0em 0.1em 0.0em;
  line-height: 1.3em;
}
#newsList li.explosion {
  color: var(--color-explosion);
  padding: 0.1em 0.0em 0.1em 0.8em;
}

  </style>
</head>
<body>

<div id="tooltip"></div>

<div id="mainLayout">
  <div>
    <div id="canvasWrapper" style="position:relative; display:inline-block;">
      <canvas id="starmap"></canvas>
      <div id="infoBox">
        <div class="header"></div>
        <div class="infoBoxCanvasWrapper">
          <canvas id="infoBoxCanvas"></canvas>
        </div>
        <div class="footer"></div>
      </div>
    </div>

    <div id="controls">
      <label for="turnSlider">Turn: <span id="turnLabel">1</span></label>
      <input type="range" id="turnSlider" min="1" max="1" value="1">

      <button id="rewindButton">‚èÆÔ∏è</button>
      <button id="stepBackButton">‚¨ÖÔ∏è</button>
      <button id="stepForwardButton">‚û°Ô∏è</button>
      <button id="playPauseButton">‚ñ∂Ô∏è</button>
      <div>
        <button id="zoomInButton">üîç+</button>
        <button id="zoomOutButton">üîç‚àí</button>
        <button id="resetViewButton">üîÑ Reset</button>
      </div> 
    </div>
    <div id="zoom-indicator"></div>
  </div>
  <div id="sidebar">
    <div id="bubble">
      <h3 id="mapTitle">Starmap</h3>
      <a id="mapTitleLink" href="#">at planets.nu</a>
    </div>
    <div id="bubble">
      <h4 id="playerHeader">Players</h4>
      <table id="playerTable">
        <tbody></tbody>
      </table>
      <div id="playerCompressed" style="display: none;"></div>
    </div>
    <div id="bubble">
      <h4 id="newsTitle">News</h4>
      <ul id="newsList"></ul>
    </div>
  </div>
</div>

<script>
const params = new URLSearchParams(window.location.search);
const paramGameId = params.get('gameid') || '';

Promise.all([
  fetch(`starmap-${paramGameId}.json`).then(res => res.json()),
  fetch(`shiplist-${paramGameId}.json`).then(res => res.json()),
  fetch(`messagelist-${paramGameId}.json`).then(res => res.json()),
  fetch(`econreport-${paramGameId}.json`).then(res => res.json()),
  fetch(`minefields-${paramGameId}.json`).then(res => res.json())
])
  .then(([starmapData, shiplistData, messagelistData, econreportData, minefieldsData]) => {
    window.starmapData = starmapData;
    window.shiplistData = shiplistData;
    window.messagelistData = messagelistData;
    window.econreportData = econreportData.econreport;
    window.minefieldsData = minefieldsData.minefield_report;
    initializeMap();
  })
  .catch(err => {
    console.error("Failed to load data:", err);
  });

const NATIVES = {
  '0': '',
  '1': 'Hum',
  '2': 'Bov',
  '3': 'Rep',
  '4': 'Av',
  '5': 'Amorph',
  '6': 'Ins',
  '7': 'Amph',
  '8': 'Ghip',
  '9': 'Sil'
};

const NATIVE_COLORS = {
  '0': '#888',
  '1': "#0088ff",
  '2': "yellow",
  '3': "#44ff44",
  '4': "white",
  '5': "#ff4444",
  '6': "white",
  '7': "cyan",
  '8': "#0088ff",
  '9': "cyan",
};

const GOVT = {
  '0': '',
  '1': '1-Anarc',
  '2': '2-PreT',
  '3': '3-ErlT',
  '4': '4-Trib',
  '5': '5-Feud',
  '6': '6-Mon',
  '7': '7-Repr',
  '8': '8-Par',
  '9': '9-Unity'
};

const TEMP_COLOURS = [
  "#4961d2", // 0
  "#5875e1", // 1
  "#6788ee", // 5
  "#779af7", // 10
  "#88abfd", // 15
  "#9abbff", // 20
  "#aac7fd", // 25
  "#bad0f8", // 30
  "#c9d7f0", // 35
  "#d6dce4", // 40
  "#e9f7df", // 50
  "#faf3d4", // 60
  "#f7d0bc", // 70
  "#f7b89c", // 75
  "#f7a889", // 80
  "#f39475", // 85
  "#ec7f63", // 90
  "#e26952", // 95
  "#d55042", // 99
  "#c53334", // 100
]

const RESOURCE_COLOURS = {
  'neutronium': "#FFE1D5",
  'duranium': "#DAD8CE",
  'tritanium': "#92BFDB",
  'molybdenum': "#E47DA8",
  'megacredits': "#ECCB60",
}

const CLAN_THRESHOLDS = [0, 1, 2, 5, 
                   10, 20, 50, 60, 70, 80, 90,
                   100, 200, 500, 600, 700, 800, 900,
                   1_000, 2_000, 5_000, 6_000, 7_000, 8_000, 9_000,
                   10_000, 20_000, 30_000, 40_000, 50_000,
                   60_000, 70_000, 80_000, 90_000, 100_000,
                   200_000]

const THRESHOLDS = [0, 1, 2, 5,
              10, 20, 30, 40, 50, 60, 70, 80, 90,
              100, 200, 300, 400, 500, 600, 700, 800, 900,
              1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000,
              10_000, 20_000, 30_000, 40_000, 50_000]

const TEMP_THRESHOLDS = [0, 1, 5, 10, 15, 20, 25, 30, 35, 40, 50, 60, 70, 75, 80, 85, 90, 95, 99, 100]

const canvas = document.getElementById('starmap');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');
const infoBoxCanvas = document.getElementById('infoBoxCanvas');
const infoBoxCtx = infoBoxCanvas.getContext('2d');

let starmapTree = null;
const shipTrees = {};
const newsTrees = {};
const starClusters = [];
const nebulas = [];

let maxTurn = 1;
let currentTurnId = 1;

let isPlaying = false;
let playInterval = null;
let animationFrameId = null;

const animationSettings = {
  framesPerTurn: 30,
  frameDuration: 1000 / 60, // ~60fps
  currentFrame: 0,
  currentTurn: 0
};

let planetOwner = {};
let starbaseSet = new Set();
let infoBoxPoint = {x: 0, y: 0};

/* zoom and pan */
const MIN_ZOOM = 0.1;
const MAX_ZOOM = 40.0;

let zoom = 1.5;
let mapWidth = 0;
let mapHeight = 0;
let bounds = {
    left: 0,
    right: 0,
    bottom: 0,
    top: 0
};
let baseScale = 1.0;
let centerOffsetX = 0;
let centerOffsetY = 0;
let offsetX = 0;
let offsetY = 0;
let isDragging = false;
let dragStart = { x: 0, y: 0 };

let tx = null;
let ty = null;
let invTx = null;
let invTy = null;

/* kd-tree for fast search */

class KDNode {
  constructor(point, axis = 0, left = null, right = null) {
    this.point = point;
    this.axis = axis;
    this.left = left;
    this.right = right;
  }
}

function buildKDTree(points, depth = 0) {
  if (!points.length) return null;

  const axis = depth % 2;
  const key = axis === 0 ? "x" : "y";

  points.sort((a, b) => a[key] - b[key]);
  const mid = Math.floor(points.length / 2);

  return new KDNode(
    points[mid],
    axis,
    buildKDTree(points.slice(0, mid), depth + 1),
    buildKDTree(points.slice(mid + 1), depth + 1)
  );
}

function distSq(a, b) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return dx * dx + dy * dy;
}

function nearestKD(node, target, radiusSq = Infinity, best = { point: null, distSq: Infinity }) {
  if (!node) return best;

  const axis = node.axis;
  const key = axis === 0 ? 'x' : 'y';

  const d = distSq(target, node.point);
  if (d < best.distSq && d < radiusSq) {
    best = { point: node.point, distSq: d };
  }

  const diff = target[key] - node.point[key];
  const close = diff < 0 ? node.left : node.right;
  const away = diff < 0 ? node.right : node.left;

  best = nearestKD(close, target, radiusSq, best);

  // Check if we should search the other branch
  if (diff * diff < best.distSq) {
    best = nearestKD(away, target, radiusSq, best);
  }

  return best;
}

function rangeKD(node, target, radiusSq, results = []) {
  if (!node) return results;

  const axis = node.axis;
  const key = axis === 0 ? 'x' : 'y';

  const dx = target.x - node.point.x;
  const dy = target.y - node.point.y;
  const distSq = dx * dx + dy * dy;

  if (distSq <= radiusSq) {
    results.push({ point: node.point, distSq });
  }

  const diff = target[key] - node.point[key];
  const close = diff < 0 ? node.left : node.right;
  const away = diff < 0 ? node.right : node.left;

  // Always check the close side
  rangeKD(close, target, radiusSq, results);

  // Check away side only if hyperplane is within radius
  if (diff * diff <= radiusSq) {
    rangeKD(away, target, radiusSq, results);
  }

  return results;
}

function closestGrouped(results) {
  if (!results.length) return [];

  // Find the minimum distance
  let minDistSq = Infinity;
  for (const r of results) {
    if (r.distSq < minDistSq) minDistSq = r.distSq;
  }

  // Filter all results that are exactly at that distance
  return results.filter(r => r.distSq === minDistSq);
}

function getPlanetOwners(turnIndex) {
  const ownerString = starmapData.planet_owners[turnIndex - 1];
  const owners = {};
  for (let i = 0; i < ownerString.length; i++) {
    const ch = ownerString[i];
    const owner = parseInt(ch, 36);  // base-36 decode
    owners[i] = owner;  // planet ID is index, planet "0" is unused
  }
  return owners;
}

function getShipsForTurn(turn) {
  const raw = shiplistData.shiplist[turn - 1];
  const result = [];
  if (!raw) return result;

  for (const key in raw) {
    const [xStr, yStr] = key.split(",");
    const x = parseInt(xStr, 10);
    const y = parseInt(yStr, 10);

    const values = raw[key];
    for (let i = 0; i < values.length; i += 2) {
      const uid = values[i];
      const ammo = values[i + 1];

      const info = shiplistData.shipinfo[uid];
      if (!info) continue;
      rec = shiplistData.shipdescs[info.shipdesc]
      shipdesc = rec[0]
      bv = rec[1]
      dv = rec[2]
      sv = bv + (dv * 2)
      result.push({
        uid,
        id: info.id,
        name: info.name,
        x,
        y,
        ammo,
        ownerid: info.ownerid,
        desc: shipdesc,
        bv: bv,
        dv: dv,
        sv: sv
      });
    }
  }
  return result;
}

function getMinefieldsForTurn(turn) {
  const raw = window.minefieldsData.minefields[turn - 1] || "";
  return raw
    .split(':')                  // split multiple records
    .filter(s => s)              // drop empty
    .map(record => {
      const [ti, x, y, owner, mines, radius] = record.split(',');
      return {
        type:     ti.charAt(0) === 'W' ? 'web' : 'normal',
        id:       parseInt(ti.slice(1), 10),
        x:        parseInt(x, 10),
        y:        parseInt(y, 10),
        ownerId:  parseInt(owner, 10),
        mines:    parseInt(mines, 10),
        radius:   parseInt(radius, 10)
      };
    });
}

function isStarbase(planetId) {
  return starbaseSet.has(planetId);
}

function getColor(ownerid) {
  const player = starmapData.players.find(p => p.id === ownerid);
  return player ? player.color : "#888888";
}

function updateTurn(turnId) {
  currentTurnId = turnId;
  planetOwner = getPlanetOwners(currentTurnId)
  starbaseSet = new Set(starmapData.starbases[currentTurnId - 1] || []);
  document.getElementById("turnLabel").textContent = turnId;
  drawMap();
  updateNewsPanel(turnId);
  updateInfoBox(turnId)
}

function scaleRadius(base, zoom, min = 2) {
  max = base * 10;
  return Math.max(min, Math.min(max, base * zoom));
}

function hexToR(h) { return parseInt((cutHex(h)).substring(0, 2), 16) }
function hexToG(h) { return parseInt((cutHex(h)).substring(2, 4), 16) }
function hexToB(h) { return parseInt((cutHex(h)).substring(4, 6), 16) }
function cutHex(h) { return (h.charAt(0) == "#") ? h.substring(1, 7) : h }

function colorToRGBA(color, alpha) {
    if (color.startsWith("rgba("))
        return color;
    var red = hexToR(color);
    var green = hexToG(color);
    var blue = hexToB(color);

    return "rgba(" + red + ", " + green + ", " + blue + ", " + alpha + ")";
}

function drawCircle(ctx, x, y, radius, color) {
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, 2 * Math.PI);
  ctx.fillStyle = color;
  ctx.fill();
}

function drawOpenCircle(ctx, x, y, radius, color) {
  const OFFSET = -1
  ctx.beginPath();
  ctx.arc(x + OFFSET, y + OFFSET, radius, 0, 2 * Math.PI);
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.stroke();
}

function drawCross(ctx, x, y, size, color) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x - size, y);
  ctx.lineTo(x + size, y);
  ctx.moveTo(x, y - size);
  ctx.lineTo(x, y + size);
  ctx.stroke();
}

function drawRect(ctx, x, y, width, height, color) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.strokeRect(x, y, width, height);
}

function drawSquare(ctx, x, y, size, color) {
  const width = size * Math.SQRT2;
  const height = size;
  const halfW = width / 2;
  const halfH = height / 2;

  const topLeft = { x: x - halfW, y: y - halfH };
  const topRight = { x: x + halfW, y: y - halfH };
  const bottomRight = { x: x + halfW, y: y + halfH };
  const bottomLeft = { x: x - halfW, y: y + halfH };

  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.strokeRect(topLeft.x, topLeft.y, width, height);

  return { topLeft, topRight, bottomRight, bottomLeft };
}

function drawLeftSlash(ctx, corners, color) {
  ctx.beginPath();
  ctx.moveTo(corners.topLeft.x, corners.topLeft.y);
  ctx.lineTo(corners.bottomRight.x, corners.bottomRight.y);
  ctx.strokeStyle = color;
  ctx.stroke();
}

function drawRightSlash(ctx, corners, color) {
  ctx.beginPath();
  ctx.moveTo(corners.topRight.x, corners.topRight.y);
  ctx.lineTo(corners.bottomLeft.x, corners.bottomLeft.y);
  ctx.strokeStyle = color;
  ctx.stroke();
}

function drawSlashedRect(ctx, x, y, size, color) {
  const corners = drawSquare(ctx, x, y, size, color);
  drawLeftSlash(ctx, corners, color);
}

function drawCrossedRect(ctx, x, y, size, color) {
  const corners = drawSquare(ctx, x, y, size, color);
  drawLeftSlash(ctx, corners, color);
  drawRightSlash(ctx, corners, color);
}

function drawTriangle(ctx, x, y, size, color) {
  const Y_OFFSET = -3
  const base = size * Math.SQRT2;
  const halfBase = base / 2;
  const halfHeight = size / 2;

  ctx.beginPath();
  ctx.moveTo(x, y - halfHeight + Y_OFFSET);                 // Top vertex
  ctx.lineTo(x - halfBase, y + halfHeight + Y_OFFSET);      // Bottom left
  ctx.lineTo(x + halfBase, y + halfHeight + Y_OFFSET);      // Bottom right
  ctx.closePath();

  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.stroke();
}

function drawNebula(ctx, x, y, neb, ctx) {
  var rad = neb.radius * zoom;
  var green = 200 + (neb.gas * 10);
  var blue = 200 - (neb.gas * 10);
  var edge = 0;

  var grad = ctx.createRadialGradient(x, y, 0, x, y, rad);
  grad.addColorStop(0, "rgba(0, " + green + ", " + blue + ", " + neb.intensity / 400 + ")");
  
  grad.addColorStop(1, "rgba(0, " + green + ", " + blue + ", " + edge + ")");
  ctx.fillStyle = grad;

  ctx.beginPath();
  ctx.arc(x, y, rad, 0, Math.PI * 2, false);
  ctx.closePath();
  ctx.fill();
}

function drawStarCluster(ctx, x, y, star) {
  var rad = star.radius * zoom;

  var color = "#FF0000";
  if (star.temp > 3000 && star.temp <= 6000)
      color = "#FFA500";
  if (star.temp > 6000 && star.temp <= 10000)
      color = "#A52A2A";
  if (star.temp > 10000 && star.temp <= 20000)
      color = "#FFFFFF";
  if (star.temp > 20000)
      color = "#B0E0E6";

  //radiation
  var opacity = Math.max(0.4 * star.temp / 65000, 0.2);
  var edge = 0.01;

  var effectRad = Math.sqrt(star.mass) * zoom;
  var grad = ctx.createRadialGradient(x, y, 0, x, y, effectRad);
  grad.addColorStop(0, colorToRGBA(color, opacity));
  grad.addColorStop(1, colorToRGBA(color, edge));
  ctx.fillStyle = grad;

  ctx.beginPath();
  ctx.arc(x, y, effectRad * .67, 0, Math.PI * 2, false);
  ctx.closePath();
  ctx.fill();

  // circle
  var grad = ctx.createRadialGradient(x, y, 0, x, y, rad);
  grad.addColorStop(0, colorToRGBA(color, 0.25));
  grad.addColorStop(1, colorToRGBA(color, 0.05));
  ctx.fillStyle = grad;

  ctx.beginPath();
  ctx.arc(x, y, rad * .67, 0, Math.PI * 2, false);
  ctx.closePath();
  ctx.fill();

  //diamond
  var halfRad = rad / 4 * .67;
  var grad = ctx.createRadialGradient(x, y, 0, x, y, halfRad);
  grad.addColorStop(0, colorToRGBA(color, 1));
  grad.addColorStop(1, colorToRGBA(color, 0));
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.moveTo(x - halfRad, y);
  ctx.lineTo(x, y - halfRad);
  ctx.lineTo(x + halfRad, y);
  ctx.lineTo(x, y + halfRad);
  ctx.closePath();
  ctx.fill();
}

/* --- infobox functions --- */

function tval(val, thresholds) {
  return thresholds[parseInt(val, 36)];
}

function nval(val, names) {
  return names[val];
}

function buildEcon(econrec) {
  const [temp, nativetype, nativegovernment, nativeclans, clans, megacredits, neutronium, molybdenum, duranium, tritanium, groundneutronium, groundmolybdenum, groundduranium, groundtritanium] = econrec;
  return {
    temp:             tval(temp, TEMP_THRESHOLDS),
    tempColor:        tval(temp, TEMP_COLOURS),
    nativeRace:       nval(nativetype, NATIVES),
    nativeColor:      nval(nativetype, NATIVE_COLORS),
    government:       nval(nativegovernment, GOVT),
    nativeClans:      tval(nativeclans, CLAN_THRESHOLDS),
    clans:            tval(clans, CLAN_THRESHOLDS),
    megacredits:      tval(megacredits, THRESHOLDS),
    neutronium:       tval(neutronium, THRESHOLDS),
    molybdenum:       tval(molybdenum, THRESHOLDS),
    duranium:         tval(duranium, THRESHOLDS),
    tritanium:        tval(tritanium, THRESHOLDS),
    groundneutronium: tval(groundneutronium, THRESHOLDS),
    groundmolybdenum: tval(groundmolybdenum, THRESHOLDS),
    groundduranium:   tval(groundduranium, THRESHOLDS),
    groundtritanium:  tval(groundtritanium, THRESHOLDS)
  };
}

/**
 * Map ‚Äúval‚Äù onto a [0..3] width and a [0..10] height.
 * For any v < 11, returns {0,0}.
 */
function getWedgeWidthAndHeight(val) {
  if (val < 11) {
    return {width: 0, height: 0};
  }
  const n = val - 1;
  const width = Math.min(3, Math.trunc(Math.log10(n)));
  const divisor = 10 ** width;
  const height = Math.min(Math.round(n / divisor), 10);
  return {width, height};
}

function drawResources(ctx, x, y, econ, ground = false) {
  const wedge   = 2 * Math.PI / 24;    // one ‚Äúunit‚Äù of arc
  const baseH   = 20;                  // minimum radius
  const deltaH  = 5;                   // extra radius per height unit

  // pick either the ‚Äúsurface‚Äù or ‚Äúground‚Äù resource keys
  const rsrcs = ground
    ? ["groundneutronium", "groundduranium", "groundtritanium", "groundmolybdenum"]
    : ["neutronium",      "duranium",      "tritanium",      "molybdenum",      "megacredits"];

  // 1) collect width/height units for each resource
  const vals = {};
  rsrcs.forEach(rsrc => {
    vals[rsrc] = getWedgeWidthAndHeight(econ[rsrc]);
  });

  // 2) total up all the ‚Äúwidth‚Äù units, then convert to arc
  const totalUnits = rsrcs.reduce((sum, rsrc) => sum + vals[rsrc].width, 0);
  const totalArc   = totalUnits * wedge;

  // 3) starting angle: six wedges offset, then center the whole pie
  let angle = ground
    ?  6 * wedge + (totalArc / 2)
    : -6 * wedge - (totalArc / 2);

  // 4) draw each slice in turn
  rsrcs.forEach(rsrc => {
    const { width, height: hUnits } = vals[rsrc];
    const arc      = width * wedge;
    const radius   = baseH + hUnits * deltaH;
    const start    = angle;
    const end      = ground ? angle - arc : angle + arc;

    ctx.beginPath();
    ctx.moveTo(x, y);
    // if ground, draw clockwise (anticlockwise=true), else ccw
    ctx.arc(x, y, radius, start, end, ground);
    // pick colour: strip "ground" prefix when in ground mode
    const colourKey = ground ? rsrc.substring(6) : rsrc;
    ctx.fillStyle = RESOURCE_COLOURS[colourKey];
    ctx.fill();

    angle = end;
  });
}

/**
 * Returns the last updated econ value for a given planet and turn
 */
function getPlanetStats(planetId, turnId) {
  if (turnId < 1) {
    return "unknown";
  }
  const turnData = econreportData.planets[turnId - 1] || {};
  return turnData.hasOwnProperty(planetId) ? turnData[planetId] : getPlanetStats(planetId, turnId - 1);
}

function drawPopn(ctx, x, y, clans, color, natives = false) {
  const dir = natives ? -1 : 1;

  // simple 1-clan line
  if (clans === 1) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + dir * 8, y);
    ctx.stroke();
    return;
  }

  // up to 9 clans: two parallel lines
  if (clans < 10) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + dir * 8, y);
    ctx.moveTo(x, y - 4);
    ctx.lineTo(x + dir * 8, y - 4);
    ctx.stroke();
    return;
  }

  // larger populations: stacked boxes + internal bars
  const log10 = Math.min(Math.trunc(Math.log10(clans)), 5);
  const div   = Math.pow(10, log10);
  const boxes = Math.min(Math.round(clans / div), 12);
  const bars  = log10;
  const height = log10 * 2 + 2;
  const width  = log10 * 4 + 4;
  const y0     = y - height;

  for (let i = 0; i < boxes; i++) {
    const y2 = y0 - (height + 2) * i;
    const rectX = x + (natives ? -width : 0);

    // draw outer box
    drawRect(ctx, rectX, y2, width, height, color);

    // every third box: a horizontal divider 1px down from top
    if (i % 3 === 2) {
      ctx.beginPath();
      ctx.moveTo(x, y2 + 1);
      ctx.lineTo(x + dir * width, y2 + 1);
      ctx.stroke();
    }

    // vertical bars indicating the log scale
    for (let j = 1; j < bars; j++) {
      const barX = x + dir * (width - j);
      ctx.beginPath();
      ctx.moveTo(barX, y2);
      ctx.lineTo(barX, y2 + height);
      ctx.stroke();
    }
  }
}

function updateInfoBoxPlanet(targetPlanetId) {
  const header = document.querySelector('#infoBox .header');
  const footer = document.querySelector('#infoBox .footer');
  const planet = starmapData.planets.find(p => p.id === targetPlanetId);
  const starbaseSet = new Set(starmapData.starbases[currentTurnId - 1] || []);
  let starbase = starbaseSet.has(targetPlanetId)
  if (!planet) {
    return;
  }
  const ownerid = getPlanetOwners(currentTurnId)[targetPlanetId];
  let ownerLabel = "Unowned";
  if (ownerid) {
    const player = starmapData.players.find(p => p.id === ownerid);
    ownerLabel = `[${ownerid}] ${player.race}`;
  }
  const econrec = getPlanetStats(targetPlanetId, currentTurnId);
  const econ = buildEcon(econrec);
  const color = getColor(ownerid);

  const ctx = infoBoxCtx;
  const size = infoBoxCanvas.width;
  ctx.clearRect(0, 0, size, size);
  drawRect(ctx, 0, 0, size, size, color);

  // owner
  ctx.font          = `12px sans-serif`;

  ctx.textAlign     = 'left';
  ctx.textBaseline  = 'middle';
  ctx.fillStyle     = color;
  ctx.fillText(ownerLabel, 8, size - 10);

  // temp
  ctx.textAlign     = 'right';
  ctx.fillStyle     = econ.tempColor;
  ctx.fillText(`${econ.temp}¬∞`, size - 6, 12);

  const planetX = size / 2;
  const planetY = size / 2;

  drawResources(ctx, planetX, planetY, econ, false);
  drawResources(ctx, planetX, planetY, econ, true);
  // draw the planet
  drawCircle(ctx, planetX, planetY, 20, econ.tempColor);

  if (starbase) {
    ctx.font          = `12px sans-serif`;
    ctx.textAlign     = 'right';
    ctx.textBaseline  = 'middle';
    ctx.fillStyle     = color;
    ctx.fillText('‚®Å', size - 8, 28);
  }

  if (econ.nativeRace) {
    ctx.textAlign     = 'rights';
    ctx.textBaseline  = 'middle';
    ctx.fillStyle     = econ.nativeColor;
    ctx.fillText(`${econ.government} ${econ.nativeRace}`, size - 6, size - 10);
    drawPopn(ctx, size - 6, size - 20, econ.nativeClans, econ.nativeColor, true);
  }

  if (ownerid) {
    drawPopn(ctx, 6, size - 20, econ.clans, color);
  }

  header.innerHTML = `<strong>P${planet.id}-${planet.name}</strong><br>`
}

/* --- end infobox functions --- */
function updateZoomIndicator() {
  const zoomDisplay = (zoom * 100).toFixed(0) + "%";
  document.getElementById("zoom-indicator").textContent = `Zoom: ${zoomDisplay}`;
}

function getProjectedPositions(x, y) {
  if (!starmapData.spherical) return [{ x, y, primary: true }];

  const w = starmapData.width + 20;
  const h = starmapData.height + 20;
  const offsets = [
    [-w, -h], [0, -h], [w, -h],
    [-w, 0],  [0, 0],  [w, 0],
    [-w, h],  [0, h],  [w, h]
  ];

  return offsets.map(([dx, dy]) => ({
    x: x + dx,
    y: y + dy,
    primary: dx === 0 && dy === 0
  }));
}

function deproject(mapX, mapY) {
  const w = starmapData.width + 20;
  const h = starmapData.height + 20;

  const dx = Math.trunc(mapX / w) - 1; // center tile is at (w, h)
  const dy = Math.trunc(mapY / h) - 1;
  console.log(`deproject: mapX, mapY: ${mapX},${mapY}, dx,dy: ${dx},${dy} -> ${mapX - dx * w},${mapY - dy * h}`)

  return {
    x: mapX - dx * w,
    y: mapY - dy * h
  };
}

function interpolate(a, b, t) {
  return a + (b - a) * t;
}

function interpolateWrapped(a, b, range, t) {
  let delta = b - a;

  if (Math.abs(delta) > range / 2) {
    // Take the wrapped (shorter) path
    if (delta > 0) {
      b -= range;
    } else {
      b += range;
    }
  }

  return a + (b - a) * t;
}

function drawGrid(ctx) {
  if (zoom > 30) {
    ctx.strokeStyle = 'rgba(241,241,255,0.1)';
  } else if (zoom > 20) {
    ctx.strokeStyle = 'rgba(241,241,255,0.07)';
  } else {
    ctx.strokeStyle = 'rgba(241,241,241,0.05)';
  }
  ctx.lineWidth = 1;
  const gridSize = 1;      // world‚Äêspace spacing
  const dx = 0.5;
  const dy = 0.5;
  // vertical lines
  for (let x = Math.ceil(bounds.left / gridSize) * gridSize; x <= bounds.right; x += gridSize) {
    const sx = tx(x + dx);
    ctx.beginPath();
    ctx.moveTo(sx, 0);
    ctx.lineTo(sx, canvas.height);
    ctx.stroke();
  }

  // horizontal lines
  for (let y = Math.ceil(bounds.bottom / gridSize) * gridSize; y <= bounds.top; y += gridSize) {
    const sy = ty(y + dy);
    ctx.beginPath();
    ctx.moveTo(0, sy);
    ctx.lineTo(canvas.width, sy);
    ctx.stroke();
  }
}

function drawMap(options = {}) {
  const {
    turn = currentTurnId,
    nextTurn = null,
    t = 0  // t: 0.0‚Äì1.0 interpolation factor between turn and nextTurn
  } = options;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const mapwidth = starmapData.width;
  const magicPadding = 20;
  const trueWidth = mapwidth + magicPadding;
  const trueHeight = starmapData.height + magicPadding;

  if (starmapData.spherical) {
    bounds = {
      left: trueWidth,
      right: trueWidth * 2,
      bottom: trueHeight,
      top: trueHeight * 2
    };
  } else {
    const halfWidth = trueWidth / 2 + magicPadding;
    const halfHeight = trueHeight / 2 + magicPadding;
    bounds = {
      left: 2000 - halfWidth,
      right: 2000 + halfWidth,
      bottom: 2000 - halfHeight,
      top: 2000 + halfHeight
    };
  }

  mapWidth = bounds.right - bounds.left;
  mapHeight = bounds.top - bounds.bottom;

  baseScale = Math.min(canvas.width / mapWidth, canvas.height / mapHeight);
  const scaled = baseScale * zoom;

  centerOffsetX = (canvas.width - mapWidth * scaled) / 2;
  centerOffsetY = (canvas.height - mapHeight * scaled) / 2;

  tx = function(x) {
    return (x - bounds.left) * scaled + centerOffsetX + offsetX;
  }

  ty = function(y) {
    return (bounds.top - y) * scaled + centerOffsetY + offsetY;
  }

  invTx = function(sx) {
    return ((sx - offsetX - centerOffsetX) / scaled) + bounds.left;
  }

  invTy = function(sy) {
    return (bounds.top - ((sy - offsetY - centerOffsetY) / scaled));
  }

  for (const starCluster of starClusters) {
    const x = starCluster.x;
    const y = starCluster.y;
    const positions = getProjectedPositions(x, y);
    for (const position of positions) {
      const sx = Math.trunc(tx(position.x));
      const sy = Math.trunc(ty(position.y));
      drawStarCluster(ctx, sx, sy, starCluster);
    }
  }

  for (const nebula of nebulas) {
    const x = nebula.x;
    const y = nebula.y;
    const positions = getProjectedPositions(x, y);
    for (const position of positions) {
      const sx = Math.trunc(tx(position.x));
      const sy = Math.trunc(ty(position.y));
      drawNebula(ctx, sx, sy, nebula, ctx);
    }
  }

  if (zoom > 15.0) {
    drawGrid(ctx);
  }

  const planetList = Object.values(starmapData.planets);
  for (const planet of planetList) {
    const x = planet.x;
    const y = planet.y;
    const ownerId = planetOwner[planet.id] || 0;
    const color = getColor(ownerId);

    const positions = getProjectedPositions(x, y);
    for (const position of positions) {
      const sx = Math.trunc(tx(position.x));
      const sy = Math.trunc(ty(position.y));
      drawCircle(ctx, sx, sy, scaleRadius(1, zoom), color);

      if (isStarbase(planet.id)) {
        drawCross(ctx, sx, sy, scaleRadius(5, zoom), color);
      }
    }
  }

  const minefields = getMinefieldsForTurn(turn);
  minefields.forEach(mf => {
    const pos = getProjectedPositions(mf.x, mf.y)[0];
    const sx  = tx(pos.x), sy = ty(pos.y);
    drawCircle(ctx, sx, sy, scaleRadius(mf.radius, zoom), colorToRGBA(getColor(mf.ownerId), 0.3));
  });

  const drawnPositions = new Set();
  const shipsA = getShipsForTurn(turn);
  // Sort by sv descending, so we can only draw the highest sv ship at a given location 
  shipsA.sort((a, b) => b.sv - a.sv);
  const shipsB = nextTurn !== null ? getShipsForTurn(nextTurn) || [] : [];

  const shipMapB = new Map(shipsB.map(s => [s.uid, s]));

  for (const shipA of shipsA) {
    const shipB = shipMapB.get(shipA.uid);
    let x = shipA.x;
    let y = shipA.y;

    if (shipB && nextTurn !== null) {
      // Interpolate position
      x = interpolateWrapped(shipA.x, shipB.x, trueWidth, t);
      y = interpolateWrapped(shipA.y, shipB.y, trueHeight, t);

      // Draw partial trail
      const maxTrail = 1.0;
      const trailBack = maxTrail * (1 - t);  // shrinking trail
      const fStart = Math.max(0, t - trailBack);
      const fEnd = t;

      const x0 = tx(interpolateWrapped(shipA.x, shipB.x, trueWidth, fStart));
      const y0 = ty(interpolateWrapped(shipA.y, shipB.y, trueHeight, fStart));
      const x1 = tx(interpolateWrapped(shipA.x, shipB.x, trueWidth, fEnd));
      const y1 = ty(interpolateWrapped(shipA.y, shipB.y, trueHeight, fEnd));

      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(x1, y1);
      ctx.strokeStyle = getColor(shipA.ownerid);
      ctx.lineWidth = 3;
      ctx.setLineDash([1, 4]);  // Dotted trail
      ctx.stroke();
      ctx.setLineDash([]);
    }

    const color = getColor(shipA.ownerid);
    const positions = getProjectedPositions(x, y);
    const sv = shipA.sv;
    for (const { x: px, y: py } of positions) {
      const key = `${px},${py}`;
      if (drawnPositions.has(key)) continue;

      drawnPositions.add(key);
      const sx = tx(px);
      const sy = ty(py);
      const r = scaleRadius(6, zoom);

      // Choose shape by SV thresholds
      if (sv >= 2000) {
        drawCrossedRect(ctx, sx, sy, r, color);
      } else if (sv >= 1500) {
        drawSlashedRect(ctx, sx, sy, r, color);
      } else if (sv >= 1000) {
        drawSquare(ctx, sx, sy, r, color);
      } else if (ctx, sv >= 500) {
        drawTriangle(ctx, sx, sy, r, color);
      } else if (sv >= 250) {
        drawOpenCircle(ctx, sx, sy, scaleRadius(4, zoom), color);
      } else {
        drawOpenCircle(ctx, sx, sy, scaleRadius(2, zoom), color);
      }
    }
  }

  const visibleNews = getVisibleNews(currentTurnId);
  // draw explosions on the map
  const explosionSz = Math.round(Math.min(60, Math.max(6, 10 * zoom)));
  ctx.font          = `${explosionSz}px sans-serif`;
  ctx.textAlign     = 'center';
  ctx.textBaseline  = 'middle';
  ctx.globalAlpha = 1.0 - t;
  for (const item of visibleNews) {
    const hasExplosion = item.news.some(n => n.type === 'EXPLOSION');
    if (!hasExplosion) continue;
    const sx = tx(item.x + 0.8), sy = ty(item.y - 0.8);
    ctx.fillText('üí•', sx, sy);
  }
  ctx.globalAlpha = 1.0;

  const borderLeft   = tx(bounds.left + magicPadding);
  const borderBottom = ty(bounds.bottom + magicPadding);
  const borderRight  = tx(bounds.right + magicPadding);
  const borderTop    = ty(bounds.top + magicPadding);

  ctx.strokeStyle = "#444";
  ctx.lineWidth = 1;

  ctx.strokeRect(
    borderLeft,
    borderTop,
    borderRight - borderLeft,
    borderBottom - borderTop
  );
  
  updateZoomIndicator()
}

canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const mapX = invTx(mx);
  const mapY = invTy(my);
  let hoverRadius = Math.min(Math.max(50, 25 * zoom), 100);
  let mousePoint = { x: mapX, y: mapY };

  const planetResult = nearestKD(starmapTree, mousePoint, hoverRadius);
  const planet = planetResult.point;

  const turn = parseInt(document.getElementById("turnSlider").value);
  const shipTree = shipTrees[turn];
  const shipMatches = closestGrouped(shipTree ? rangeKD(shipTree, mousePoint, hoverRadius) : []);

  if (planet || shipMatches.length > 0) {
    let html = "";

    // Ships
    shipMatches.sort((a, b) => a.point.sv - b.point.sv);
    for (const match of shipMatches) {
      const ship = match.point;
      const player = starmapData.players.find(p => p.id === ship.ownerid);
      const color = player ? player.color : "#888";
      const desc = ship.desc;
      const ammoText = ship.bv > 0 ? `/${ship.ammo}` : "";
      html += `<div style="color: ${color};"> ‚ùØ S${ship.id} ${ship.name} - ${desc}${ammoText}</div>`;
    }

    // Planet
    if (planet) {
      const ownerId = planetOwner[planet.id] || 0;
      const player = starmapData.players.find(p => p.id === ownerId);
      const ownerName = player ? player.name : "Unowned";
      const ownerColor = player ? player.color : "#888";
      const star = isStarbase(planet.id) ? "‚®Å " : "‚óØ ";
      html += `<div style="margin-top: 4px; color: ${ownerColor};">${star} P${planet.id} ${planet.name} (${ownerName})]</div>`;
      tooltip.style.borderLeftColor = ownerColor;
    } else {
      tooltip.style.borderLeftColor = "#666";
    }
    html += `<div style="text-align:right; font-size:0.8em;">${Math.round(mapX)},${Math.round(mapY)}</div>`;

    tooltip.innerHTML = html;
    tooltip.style.left = `${e.pageX + 10}px`;
    tooltip.style.top = `${e.pageY + 10}px`;
    tooltip.style.display = 'block';
  } else {
    tooltip.style.display = 'none';
  }
});

canvas.addEventListener('mouseleave', () => {
  tooltip.style.display = 'none';
});

function resizeCanvasToMapAspect() {
  const wrapper = document.getElementById("canvasWrapper");
  const canvas = document.getElementById("starmap");

  const mapWidth = starmapData.width;
  const mapHeight = starmapData.height;
  const aspectRatio = mapWidth / mapHeight;

  // Available space
  const maxWidth = Math.min(wrapper.clientWidth, 900); // keep canvas modest
  const maxHeight = wrapper.clientHeight;

  // Fit while preserving aspect ratio
  if (maxWidth / maxHeight > aspectRatio) {
    canvas.height = maxHeight;
    canvas.width = Math.floor(maxHeight * aspectRatio);
  } else {
    canvas.width = maxWidth;
    canvas.height = Math.floor(maxWidth / aspectRatio);
  }

  infoBoxCanvas.width = 170;
  infoBoxCanvas.height = 170;
}

window.addEventListener("resize", () => {
  resizeCanvasToMapAspect();
  drawMap();
});

function initializeMap() {
  // build kdtree for planets
  starmapTree = buildKDTree(starmapData.planets);

  // add any star clusters
  starClusters.push(...starmapData.starclusters);

  // add any nebulas
  nebulas.push(...starmapData.nebulas);

  // build kdtree for ships for each turn
  for (let turn = 0; turn < shiplistData.shiplist.length; turn++) {
    shipTrees[turn] = buildKDTree(getShipsForTurn(turn));
  }

  // build kdtree for news for each turn
  const news = newsreader.parse(messagelistData.messagelist);
  for (let turn = 0; turn < news.length; turn++) {
    newsTrees[turn] = buildKDTree(news[turn]);
  }

  // page title
  const title = starmapData.title || "Starmap";
  document.getElementById("pageTitle").textContent = title;
  document.getElementById("mapTitle").textContent = title;

  // link to game on planets nu
  const link = document.getElementById("mapTitleLink");
  link.textContent = `game ${starmapData.gameid} @ planets.nu`
  link.href = `https://planets.nu/#/sector/${starmapData.gameid}`
  
  const tableBody = document.querySelector('#playerTable tbody');
  for (const player of starmapData.players) {
    const row = document.createElement('tr');
    row.innerHTML = `
      <td>${player.name}</td>
      <td>${player.race}</td>
      <td><input type="color" value="${player.color}" data-player="${player.id}"></td>
    `;
    tableBody.appendChild(row);
  }

  const compressedContainer = document.getElementById('playerCompressed');
  compressedContainer.innerHTML = '';
  for (const player of starmapData.players) {
    const box = document.createElement('div');
    box.className = 'playerBox';
    const secondWord = player.race.split(' ')[1] || player.race;
    box.textContent = secondWord.slice(0, 2);
    box.title = player.name;
    box.style.borderLeft = `6px solid ${player.color}`;
    compressedContainer.appendChild(box);
  }

  tableBody.addEventListener('input', (e) => {
    if (e.target.type === 'color') {
      const playerId = parseInt(e.target.dataset.player, 10);
      const player = starmapData.players.find(p => p.id === playerId);
      if (player) {
        player.color = e.target.value;
        drawMap();
      }
    }
  });

  document.getElementById('playerHeader').addEventListener('click', () => {
    const table = document.getElementById('playerTable');
    const compressed = document.getElementById('playerCompressed');
    const isTableVisible = table.style.display !== 'none';

    table.style.display = isTableVisible ? 'none' : '';
    compressed.style.display = isTableVisible ? '' : 'none';
  });

  const slider = document.getElementById("turnSlider");
  maxTurn = starmapData.turns;
  slider.max = maxTurn;
  slider.value = 1;
  slider.addEventListener("input", () => {
    updateTurn(parseInt(slider.value));
  });

  document.getElementById("playPauseButton").addEventListener("click", togglePlayPause);
  document.getElementById("rewindButton").addEventListener("click", rewind);
  document.getElementById("stepBackButton").addEventListener("click", () => {
    let current = parseInt(slider.value);
    if (current > 1) {
      slider.value = current - 1;
      updateTurn(parseInt(slider.value));
    }
  });

  document.getElementById("stepForwardButton").addEventListener("click", () => {
    let current = parseInt(slider.value);
    if (current < maxTurn) {
      slider.value = current + 1;
      updateTurn(parseInt(slider.value));
    }
  });

  document.getElementById("zoomInButton").addEventListener("click", () => {
    zoom *= 1.25;
    // clamp between MIN_ZOOM and MAX_ZOOM
    zoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, zoom));
    updateNewsPanel(currentTurnId);
    drawMap();
  });

  document.getElementById("zoomOutButton").addEventListener("click", () => {
    zoom /= 1.25;
    // clamp between MIN_ZOOM and MAX_ZOOM
    zoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, zoom));
    updateNewsPanel(currentTurnId);
    drawMap();
  });

  document.getElementById("resetViewButton").addEventListener("click", () => {
    zoom = 1.0;
    offsetX = 0;
    offsetY = 0;
    updateNewsPanel(currentTurnId);
    drawMap();
  });

  resizeCanvasToMapAspect();
  updateTurn(1);
}

function animateStep() {
  const {
    currentTurn,
    currentFrame,
    framesPerTurn
  } = animationSettings;

  const nextTurn = currentTurn + 1;
  const slider = document.getElementById("turnSlider");
  const max = parseInt(slider.max);

  const t = currentFrame / framesPerTurn;
  drawMap({ turn: currentTurn, nextTurn, t });

  animationSettings.currentFrame++;

  if (animationSettings.currentFrame < framesPerTurn) {
    animationFrameId = requestAnimationFrame(animateStep);
  } else {
    animationSettings.currentTurn++;
    slider.value = animationSettings.currentTurn;
    updateTurn(animationSettings.currentTurn); // update other UI

    if (animationSettings.currentTurn >= max) {
      togglePlayPause(); // Stop at last turn
    } else {
      animationSettings.currentFrame = 0;
      animationFrameId = requestAnimationFrame(animateStep);
    }
  }
}

function togglePlayPause() {
  const button = document.getElementById("playPauseButton");

  if (isPlaying) {
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
    isPlaying = false;
    button.textContent = "‚ñ∂Ô∏è";
  } else {
    isPlaying = true;
    button.textContent = "‚è∏Ô∏è";

    const slider = document.getElementById("turnSlider");
    animationSettings.currentTurn = parseInt(slider.value);
    animationSettings.currentFrame = 0;

    requestAnimationFrame(animateStep);
  }
}

function rewind() {
  const slider = document.getElementById("turnSlider");
  slider.value = 1;
  updateTurn(1);
  if (isPlaying) togglePlayPause(); // Stop playback if active
}

canvas.addEventListener("mousedown", (e) => {
  isDragging = true;
  dragStart = { x: e.clientX, y: e.clientY };
});

canvas.addEventListener("mouseup", () => {
  isDragging = false;
});

canvas.addEventListener("mouseleave", () => {
  isDragging = false;
});

canvas.addEventListener("mousemove", (e) => {
  if (isDragging) {
    const dx = e.clientX - dragStart.x;
    const dy = e.clientY - dragStart.y;
    dragStart = { x: e.clientX, y: e.clientY };
    offsetX += dx;
    offsetY += dy;
    updateNewsPanel(currentTurnId);
    drawMap();
  }
});


// update infoBoxPoint on click
canvas.addEventListener('click', e => {
  const r    = canvas.getBoundingClientRect();
  const mapX = Math.round(invTx(e.clientX - r.left));
  const mapY = Math.round(invTy(e.clientY - r.top));
  infoBoxPoint.x = mapX;
  infoBoxPoint.y = mapY;

  updateInfoBox(currentTurnId);
});

canvas.addEventListener("wheel", (e) => {
  event.preventDefault(); // prevent page scroll

  const rect = canvas.getBoundingClientRect();
  const mx = event.clientX - rect.left;
  const my = event.clientY - rect.top;

  // World coords before zoom
  const mapX = (mx - centerOffsetX - offsetX) / (baseScale * zoom) + bounds.left;
  const mapY = bounds.top - (my - centerOffsetY - offsetY) / (baseScale * zoom);

  const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1;
  zoom *= zoomFactor;

  // clamp between MIN_ZOOM and MAX_ZOOM
  zoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, zoom));

  // Recompute scale & center offsets
  const newScaled = baseScale * zoom;
  const newCenterOffsetX = (canvas.width - mapWidth * newScaled) / 2;
  const newCenterOffsetY = (canvas.height - mapHeight * newScaled) / 2;

  // Adjust pan so zoom focuses on mouse
  offsetX = mx - (mapX - bounds.left) * newScaled - newCenterOffsetX;
  offsetY = my - (bounds.top - mapY) * newScaled - newCenterOffsetY;

  centerOffsetX = newCenterOffsetX;
  centerOffsetY = newCenterOffsetY;

  updateNewsPanel(currentTurnId);
  drawMap();
}, { passive: false }); // notify browser that native scrolling will be disabled

function centerMapOn(x, y) {
  const screenCenterX = canvas.width / 2;
  const screenCenterY = canvas.height / 2;
  const scaled = baseScale * zoom;

  offsetX = screenCenterX - (x - bounds.left) * scaled - centerOffsetX;
  offsetY = screenCenterY - (bounds.top - y) * scaled - centerOffsetY;

  updateNewsPanel(currentTurnId);
  drawMap();
}

canvas.addEventListener("dblclick", (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const { x, y } = deproject(invTx(mx), invTy(my));
  centerMapOn(x, y);
});

const newsreader = {
  BATTLE: 100,
  EXPLOSION: 101,

  parse: function(newsRecords) {
    const result = [];

    for (const entry of newsRecords) {
      const turnResult = [];

      for (const key in entry) {
        const [x, y] = key.split(',').map(Number);
        const messages = entry[key];
        const newsItems = [];

        for (const record of messages) {
          const [type, ...rest] = record;

          if (type === this.BATTLE) {
            const [btype, leftId, rightId, leftName, rightName, leftOwner, rightOwner, leftSurvives, rightSurvives] = rest;
            newsItems.push({
              type: 'BATTLE',
              btype,
              leftId, rightId,
              leftName, rightName,
              leftOwner, rightOwner,
              leftSurvives, rightSurvives
            });
          } else if (type === this.EXPLOSION) {
            const [name, ownerId] = rest;
            newsItems.push({
              type: 'EXPLOSION',
              name,
              ownerId
            });
          } else {
            console.warn("Unknown news type:", type);
          }
        }

        turnResult.push({ x, y, news: newsItems });
      }

      result.push(turnResult);
    }

    return result;
  }
};

function formatNewsItem(newsItem) {
  const li = document.createElement("li");

  if (newsItem.type === "BATTLE") {
    const l = newsItem.leftSurvives ? "" : "‚ùå";
    const r = newsItem.rightSurvives ? "" : "‚ùå";
    const p = newsItem.btype === 0 ? "S" : newsItem.btype === 1 ? "‚óØ P" : "‚®Å P";

    const leftColor = getColor(newsItem.leftOwner);
    const rightColor = getColor(newsItem.rightOwner);

    li.innerHTML = `
      <span style="color: ${leftColor}">S${newsItem.leftId} ${newsItem.leftName} (${newsItem.leftOwner}) ${l}</span>
      <span> vs </span>
      <span style="color: ${rightColor}">${p}${newsItem.rightId} ${newsItem.rightName} (${newsItem.rightOwner}) ${r}</span>
    `;

  } else if (newsItem.type === "EXPLOSION") {
    const color = getColor(newsItem.ownerId);
    li.classList.add("explosion");
    li.innerHTML = `<span style="color: ${color}">üí• ${newsItem.name} (${newsItem.ownerId})</span>`;
  } else {
    li.textContent = "Unknown news type";
  }

  return li;
}

function getVisibleNews(turnId) {
  const center = {
    x: invTx(canvas.width / 2),
    y: invTy(canvas.height / 2)
  };

  // Compute the pixel‚Äêspace radius of the viewable rectangle
  const r_px = Math.hypot(canvas.width, canvas.height) / 2;

  // Convert to world units using your current scale
  const scale = baseScale * zoom;
  const r_world = r_px / scale;

  const visibleNews = rangeKD(newsTrees[turnId - 1], center, r_world * r_world).map(r => r.point);
  return visibleNews;
}


function updateNewsPanel(turnId) {
  const list = document.getElementById("newsList");
  list.innerHTML = ""; // Clear previous entries

  const visibleNews = getVisibleNews(turnId);

  for (const item of visibleNews) {
    const ul = document.createElement("ul");
    // Attach recenter handler to the whole block
    ul.addEventListener("click", () => {
      centerMapOn(item.x, item.y);
    });

    for (const newsItem of item.news) {
      const li = formatNewsItem(newsItem);
      ul.appendChild(li);
    }

    list.appendChild(ul);
  }
}

function updateInfoBox(turnId) {
  const infoBox = document.getElementById('infoBox');
  const header = document.querySelector('#infoBox .header');
  const footer = document.querySelector('#infoBox .footer');
  const planet = nearestKD(starmapTree, infoBoxPoint, 6).point;
  const shipMatches = closestGrouped(rangeKD(shipTrees[turnId], infoBoxPoint, 2));

  if (planet || shipMatches.length > 0) {
    let html = "";
    // Ships
    shipMatches.sort((a, b) => a.point.sv - b.point.sv);
    for (const match of shipMatches) {
      const ship = match.point;
      const player = starmapData.players.find(p => p.id === ship.ownerid);
      const color = player ? player.color : "#888";
      const desc = ship.desc;
      const ammoText = ship.bv > 0 ? `/${ship.ammo}` : "";
      html += `<div style="color: ${color};"> ‚ùØ S${ship.id} ${ship.name} - ${desc}${ammoText}</div>`;
    }

    if (planet) {
      infoBoxCanvas.style.display = '';
      updateInfoBoxPlanet(planet.id)
    }

    html += `<br>x: ${infoBoxPoint.x}, y: ${infoBoxPoint.y}`;
    footer.innerHTML = html;
  } else {
    infoBoxCanvas.style.display = 'none';
    header.innerHTML = "<strong>Deep Space</strong>"
    footer.innerHTML = `x: ${infoBoxPoint.x}, y: ${infoBoxPoint.y}`;
  }
}

</script>

</body>
</html>
