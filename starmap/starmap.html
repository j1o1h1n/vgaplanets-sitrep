<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title id="pageTitle">VGAP Starmap</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 10;
      font-family: sans-serif;
      background-color: #1A1B26; /* background */
      color: #7AA2F7;            /* secondary */
    }

    canvas { border: 1px solid #ccc; background-color: black; }

    input[type="color"] {
      background: none;
      border: none;
      cursor: pointer;
    }

    input[type="range"] {
      margin: 3px;
      accent-color: #7AA2F7;
    }

    button {
      background-color: #7AA2F7;  /* secondary */
      color: #24283B;             /* button-color-foreground */
      border: none;
      padding: 6px 10px;
      margin: 4px;
      border-radius: 4px;
      cursor: pointer;
    }

    button:hover {
      background-color: #8AB2FF; /* primary on hover */
    }

    #tooltip {
      position: absolute;
      background: #24283B;
      border: 1px solid #7AA2F7;
      color: #BB9AF7;
      padding: 6px 10px;
      font-size: 12px;
      font-family: sans-serif;
      pointer-events: none;
      display: none;
      border-left: 6px solid transparent;
      z-index: 10;
      max-width: 300px;
      white-space: normal;
    }

    #mapTitle {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.5em;
      letter-spacing: 0.05em;
      color: #BB9AF7; /* primary */
      margin-top: 0.5em;
    }

    #mainLayout {
      display: flex;
      align-items: flex-start;
      gap: 20px;
      padding: 20px;
      background-color: #1A1B26; /* background */
    }

    #canvasWrapper {
      max-width: 900px;
      width: 85vw;
      height: 85vh; /* fit most of the viewport */
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #1A1B26; /* match theme background */
    }

    #starmap {
      display: block;
      border: 1px solid #414868; /* panel border */
      background-color: black;
    }

    #sidebar {
      font-family: sans-serif;
      background-color: #414868;  /* panel */
      padding: 16px;
      border-radius: 8px;
      min-width: 250px;
    }

    #playerTable {
      width: 100%;
      border-collapse: collapse;
      background-color: #24283B; /* surface */
      color: #7AA2F7;            /* secondary */
    }

    #playerTable th {
      background-color: #414868; /* panel */
      color: #BB9AF7;            /* primary */
      padding: 6px;
      text-align: left;
      border-bottom: 1px solid #1A1B26;
    }

    #playerTable td {
      padding: 6px;
      border-top: 1px solid #1A1B26;
      font-size: 14px;
    }

    #controls {
      padding: 0px 20px;
    }

    #zoom-indicator {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: #a9b1d6; /* foreground from tokyo-night */
      background: rgba(36, 40, 59, 0.8); /* surface with transparency */
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-family: monospace;
      pointer-events: none;
    }
  </style>
</head>
<body>

<div id="tooltip"></div>

<div id="mainLayout">
  <div id="canvasWrapper">
    <canvas id="starmap"></canvas>
  </div>
  <div id="zoom-indicator"></div>

  <div id="sidebar">
    <h3 id="mapTitle">Starmap</h3>
    <table id="playerTable">
      <tbody></tbody>
    </table>
  </div>
</div>

<div id="controls">
  <label for="turnSlider">Turn: <span id="turnLabel">1</span></label>
  <input type="range" id="turnSlider" min="1" max="1" value="1">

  <button id="rewindButton">‚èÆÔ∏è</button>
  <button id="stepBackButton">‚¨ÖÔ∏è</button>
  <button id="stepForwardButton">‚û°Ô∏è</button>
  <button id="playPauseButton">‚ñ∂Ô∏è</button>
  <div>
    <button id="zoomInButton">üîç+</button>
    <button id="zoomOutButton">üîç‚àí</button>
    <button id="resetViewButton">üîÑ Reset</button>
  </div> 
</div>

<script>

Promise.all([
  fetch('starmap.json').then(res => res.json()),
  fetch('shiplist.json').then(res => res.json())
])
  .then(([starmapData, shiplistData]) => {
    window.starmapData = starmapData;
    window.shiplistData = shiplistData;
    initializeMap();
  })
  .catch(err => {
    console.error("Failed to load data:", err);
  });

const canvas = document.getElementById('starmap');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');
let starmapTree = null;
const shipTrees = {};
let screenPlanets = [];

let maxTurn = 1;
let currentTurnId = 1;

let isPlaying = false;
let playInterval = null;
let animationFrameId = null;

const animationSettings = {
  framesPerTurn: 30,
  frameDuration: 1000 / 60, // ~60fps
  currentFrame: 0,
  currentTurn: 0
};

let planetOwner = {};
let starbaseSet = new Set();

/* zoom and pan */
const MIN_ZOOM = 0.2;
const MAX_ZOOM = 5.0;

let zoom = 1.0;
let mapWidth = 0;
let mapHeight = 0;
let bounds = {
    left: 0,
    right: 0,
    bottom: 0,
    top: 0
};
let baseScale = 1.0;
let centerOffsetX = 0;
let centerOffsetY = 0;
let offsetX = 0;
let offsetY = 0;
let isDragging = false;
let dragStart = { x: 0, y: 0 };

let tx = null;
let ty = null;
let invTx = null;
let invTy = null;

/* kd-tree for fast search */

class KDNode {
  constructor(point, axis = 0, left = null, right = null) {
    this.point = point;
    this.axis = axis;
    this.left = left;
    this.right = right;
  }
}

function buildKDTree(points, depth = 0) {
  if (!points.length) return null;

  const axis = depth % 2;
  const key = axis === 0 ? "x" : "y";

  points.sort((a, b) => a[key] - b[key]);
  const mid = Math.floor(points.length / 2);

  return new KDNode(
    points[mid],
    axis,
    buildKDTree(points.slice(0, mid), depth + 1),
    buildKDTree(points.slice(mid + 1), depth + 1)
  );
}

function distSq(a, b) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return dx * dx + dy * dy;
}

function nearestKD(node, target, radiusSq = Infinity, best = { point: null, distSq: Infinity }) {
  if (!node) return best;

  const axis = node.axis;
  const key = axis === 0 ? 'x' : 'y';

  const d = distSq(target, node.point);
  if (d < best.distSq && d < radiusSq) {
    best = { point: node.point, distSq: d };
  }

  const diff = target[key] - node.point[key];
  const close = diff < 0 ? node.left : node.right;
  const away = diff < 0 ? node.right : node.left;

  best = nearestKD(close, target, radiusSq, best);

  // Check if we should search the other branch
  if (diff * diff < best.distSq) {
    best = nearestKD(away, target, radiusSq, best);
  }

  return best;
}

function rangeKD(node, target, radiusSq, results = []) {
  if (!node) return results;

  const axis = node.axis;
  const key = axis === 0 ? 'x' : 'y';

  const dx = target.x - node.point.x;
  const dy = target.y - node.point.y;
  const distSq = dx * dx + dy * dy;

  if (distSq <= radiusSq) {
    results.push({ point: node.point, distSq });
  }

  const diff = target[key] - node.point[key];
  const close = diff < 0 ? node.left : node.right;
  const away = diff < 0 ? node.right : node.left;

  // Always check the close side
  rangeKD(close, target, radiusSq, results);

  // Check away side only if hyperplane is within radius
  if (diff * diff <= radiusSq) {
    rangeKD(away, target, radiusSq, results);
  }

  return results;
}

function closestGrouped(results) {
  if (!results.length) return [];

  // Find the minimum distance
  let minDistSq = Infinity;
  for (const r of results) {
    if (r.distSq < minDistSq) minDistSq = r.distSq;
  }

  // Filter all results that are exactly at that distance
  return results.filter(r => r.distSq === minDistSq);
}

function getPlanetOwners(turnIndex) {
  const ownerString = starmapData.planet_owners[turnIndex - 1];
  const owners = {};
  for (let i = 0; i < ownerString.length; i++) {
    const ch = ownerString[i];
    const owner = parseInt(ch, 36);  // base-36 decode
    owners[i] = owner;  // planet ID is index, planet "0" is unused
  }
  return owners;
}

function getShipsForTurn(turn) {
  const raw = shiplistData.shiplist[turn - 1];
  const result = [];
  if (!raw) return result;

  for (let i = 0; i < raw.length; i += 4) {
    const [uid, x, y, ammo] = raw.slice(i, i + 4);
    const info = shiplistData.shipinfo[uid];
    if (!info) continue;
    result.push({
      uid,
      id: info.id,
      name: info.name,
      x,
      y,
      ammo,
      ownerid: info.ownerid,
      desc: shiplistData.shipdescs[info.shipdesc],
      bv: info.bv
    });
  }
  return result;
}

function isStarbase(planetId) {
  return starbaseSet.has(planetId);
}

function getColor(ownerid) {
  const player = starmapData.players.find(p => p.id === ownerid);
  return player ? player.color : "#888888";
}

function updateTurn(turnId) {
  currentTurnId = turnId;
  planetOwner = getPlanetOwners(currentTurnId)
  starbaseSet = new Set(starmapData.starbases[currentTurnId - 1] || []);
  document.getElementById("turnLabel").textContent = turnId;
  drawMap();
}

function scaleRadius(base, zoom, min = 2) {
  max = base * 3;
  return Math.max(min, Math.min(max, base * zoom));
}

function drawCircle(x, y, radius, color) {
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, 2 * Math.PI);
  ctx.fillStyle = color;
  ctx.fill();
}

function drawOpenCircle(x, y, radius, color) {
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, 2 * Math.PI);
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.stroke();
}

function drawCross(x, y, size, color) {
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x - size, y);
  ctx.lineTo(x + size, y);
  ctx.moveTo(x, y - size);
  ctx.lineTo(x, y + size);
  ctx.stroke();
}

function updateZoomIndicator() {
  const zoomDisplay = (zoom * 100).toFixed(0) + "%";
  document.getElementById("zoom-indicator").textContent = `Zoom: ${zoomDisplay}`;
}

function getProjectedPositions(x, y) {
  if (starmapData.mapshape !== 1) return [{ x, y, primary: true }];

  const w = starmapData.width + 20;
  const h = starmapData.height + 20;
  const offsets = [
    [-w, -h], [0, -h], [w, -h],
    [-w, 0],  [0, 0],  [w, 0],
    [-w, h],  [0, h],  [w, h]
  ];

  return offsets.map(([dx, dy]) => ({
    x: x + dx,
    y: y + dy,
    primary: dx === 0 && dy === 0
  }));
}

function interpolate(a, b, t) {
  return a + (b - a) * t;
}

function interpolateWrapped(a, b, range, t) {
  let delta = b - a;

  if (Math.abs(delta) > range / 2) {
    // Take the wrapped (shorter) path
    if (delta > 0) {
      b -= range;
    } else {
      b += range;
    }
  }

  return a + (b - a) * t;
}

function drawMap(options = {}) {
  const {
    turn = currentTurnId,
    nextTurn = null,
    t = 0  // t: 0.0‚Äì1.0 interpolation factor between turn and nextTurn
  } = options;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  screenPlanets = [];

  const mapwidth = starmapData.width;
  const magicPadding = 20;
  const trueWidth = mapwidth + magicPadding;
  const trueHeight = starmapData.height + magicPadding;

  bounds = {
    left: trueWidth,
    right: trueWidth * 2,
    bottom: trueHeight,
    top: trueHeight * 2
  };

  mapWidth = bounds.right - bounds.left;
  mapHeight = bounds.top - bounds.bottom;

  baseScale = Math.min(canvas.width / mapWidth, canvas.height / mapHeight);
  const scaled = baseScale * zoom;

  centerOffsetX = (canvas.width - mapWidth * scaled) / 2;
  centerOffsetY = (canvas.height - mapHeight * scaled) / 2;

  tx = function(x) {
    return (x - bounds.left) * scaled + centerOffsetX + offsetX;
  }

  ty = function(y) {
    return (bounds.top - y) * scaled + centerOffsetY + offsetY;
  }

  invTx = function(sx) {
    return ((sx - offsetX - centerOffsetX) / scaled) + bounds.left;
  }

  invTy = function(sy) {
    return (bounds.top - ((sy - offsetY - centerOffsetY) / scaled));
  }

  const planetList = Object.values(starmapData.planets);
  for (const planet of planetList) {
    const x = planet.x;
    const y = planet.y;
    const ownerId = planetOwner[planet.id] || 0;
    const color = getColor(ownerId);

    const positions = getProjectedPositions(x, y);
    for (const position of positions) {
      const sx = Math.trunc(tx(position.x));
      const sy = Math.trunc(ty(position.y));
      drawCircle(sx, sy, scaleRadius(1, zoom), color);

      if (isStarbase(planet.id)) {
        drawCross(sx, sy, scaleRadius(5, zoom), color);
      }
      screenPlanets.push({ id: planet.id, name: planet.name, x: sx, y: sy, trueX: position.x, trueY: position.y });
    }
  }

  const shipsA = getShipsForTurn(turn);
  const shipsB = nextTurn !== null ? getShipsForTurn(nextTurn) || [] : [];

  const shipMapB = new Map(shipsB.map(s => [s.id, s]));

  for (const shipA of shipsA) {
    const shipB = shipMapB.get(shipA.id);
    let x = shipA.x;
    let y = shipA.y;

    if (shipB && nextTurn !== null) {
      // Interpolate position
      x = interpolateWrapped(shipA.x, shipB.x, trueWidth, t);
      y = interpolateWrapped(shipA.y, shipB.y, trueHeight, t);

      // Draw partial trail
      const maxTrail = 1.0;
      const trailBack = maxTrail * (1 - t);  // shrinking trail
      const fStart = Math.max(0, t - trailBack);
      const fEnd = t;

      const x0 = tx(interpolateWrapped(shipA.x, shipB.x, trueWidth, fStart));
      const y0 = ty(interpolateWrapped(shipA.y, shipB.y, trueHeight, fStart));
      const x1 = tx(interpolateWrapped(shipA.x, shipB.x, trueWidth, fEnd));
      const y1 = ty(interpolateWrapped(shipA.y, shipB.y, trueHeight, fEnd));

      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(x1, y1);
      ctx.strokeStyle = getColor(shipA.ownerid);
      ctx.lineWidth = 1;
      ctx.setLineDash([1, 4]);  // Dotted trail
      ctx.stroke();
      ctx.setLineDash([]);
    }

    const color = getColor(shipA.ownerid);
    const positions = getProjectedPositions(x, y);
    for (const { x: px, y: py } of positions) {
      drawOpenCircle(tx(px), ty(py), scaleRadius(6, zoom), color);
    }
  }

  const borderLeft   = tx(bounds.left + magicPadding);
  const borderBottom = ty(bounds.bottom + magicPadding);
  const borderRight  = tx(bounds.right + magicPadding);
  const borderTop    = ty(bounds.top + magicPadding);

  ctx.strokeStyle = "#444";
  ctx.lineWidth = 1;

  ctx.strokeRect(
    borderLeft,
    borderTop,
    borderRight - borderLeft,
    borderBottom - borderTop
  );
  
  updateZoomIndicator()
}

canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const mapX = invTx(mx);
  const mapY = invTy(my);
  let hoverRadius = Math.min(Math.max(50, 25 * zoom), 100);
  let mousePoint = { x: mapX, y: mapY };

  const planetResult = nearestKD(starmapTree, mousePoint, hoverRadius);
  const planet = planetResult.point;

  const turn = parseInt(document.getElementById("turnSlider").value);
  const shipTree = shipTrees[turn];
  const shipMatches = closestGrouped(shipTree ? rangeKD(shipTree, mousePoint, hoverRadius) : []);

  if (planet || shipMatches.length > 0) {
    let html = "";

    // Ships
    for (const match of shipMatches) {
      const ship = match.point;
      const player = starmapData.players.find(p => p.id === ship.ownerid);
      const color = player ? player.color : "#888";
      const desc = ship.desc;
      const ammoText = ship.bv > 0 ? `/${ship.ammo}` : "";
      html += `<div style="color: ${color};"> ‚ùØ S${ship.id} ${ship.name} - ${desc}${ammoText}</div>`;
    }

    // Planet
    if (planet) {
      const ownerId = planetOwner[planet.id] || 0;
      const player = starmapData.players.find(p => p.id === ownerId);
      const ownerName = player ? player.name : "Unowned";
      const ownerColor = player ? player.color : "#888";
      const star = isStarbase(planet.id) ? "‚®Å" : "";
      html += `<div style="margin-top: 4px; color: ${ownerColor};">${star} P${planet.id} ${planet.name} (${ownerName}) [${planet.x},${planet.y}]</div>`;
      tooltip.style.borderLeftColor = ownerColor;
    } else {
      tooltip.style.borderLeftColor = "#666";
    }

    tooltip.innerHTML = html;
    tooltip.style.left = `${e.pageX + 10}px`;
    tooltip.style.top = `${e.pageY + 10}px`;
    tooltip.style.display = 'block';
  } else {
    tooltip.style.display = 'none';
  }
});

canvas.addEventListener('mouseleave', () => {
  tooltip.style.display = 'none';
});

function resizeCanvasToMapAspect() {
  const wrapper = document.getElementById("canvasWrapper");
  const canvas = document.getElementById("starmap");

  const mapWidth = starmapData.width;
  const mapHeight = starmapData.height;
  const aspectRatio = mapWidth / mapHeight;

  // Available space
  const maxWidth = Math.min(wrapper.clientWidth, 900); // keep canvas modest
  const maxHeight = wrapper.clientHeight;

  // Fit while preserving aspect ratio
  if (maxWidth / maxHeight > aspectRatio) {
    canvas.height = maxHeight;
    canvas.width = Math.floor(maxHeight * aspectRatio);
  } else {
    canvas.width = maxWidth;
    canvas.height = Math.floor(maxWidth / aspectRatio);
  }
}

window.addEventListener("resize", () => {
  resizeCanvasToMapAspect();
  drawMap();
});

function initializeMap() {
  // build kdtree for planets
  starmapTree = buildKDTree(starmapData.planets);
  // build kdtree for ships for each turn
  for (let turn = 0; turn < shiplistData.shiplist.length; turn++) {
    shipTrees[turn] = buildKDTree(getShipsForTurn(turn));
  }

  document.getElementById("pageTitle").textContent = starmapData.title || "Starmap";
  document.getElementById("mapTitle").textContent = starmapData.title || "Starmap";

  const tableBody = document.querySelector('#playerTable tbody');
  for (const player of starmapData.players) {
    const row = document.createElement('tr');
    row.innerHTML = `
      <td>${player.name}</td>
      <td>${player.race}</td>
      <td><input type="color" value="${player.color}" data-player="${player.id}"></td>
    `;
    tableBody.appendChild(row);
  }

  tableBody.addEventListener('input', (e) => {
    if (e.target.type === 'color') {
      const playerId = parseInt(e.target.dataset.player, 10);
      const player = starmapData.players.find(p => p.id === playerId);
      if (player) {
        player.color = e.target.value;
        drawMap();
      }
    }
  });

  const slider = document.getElementById("turnSlider");
  maxTurn = starmapData.turns;
  slider.max = maxTurn;
  slider.value = 1;
  slider.addEventListener("input", () => {
    updateTurn(parseInt(slider.value));
  });

  document.getElementById("playPauseButton").addEventListener("click", togglePlayPause);
  document.getElementById("rewindButton").addEventListener("click", rewind);
  document.getElementById("stepBackButton").addEventListener("click", () => {
    let current = parseInt(slider.value);
    if (current > 1) {
      slider.value = current - 1;
      updateTurn(parseInt(slider.value));
    }
  });

  document.getElementById("stepForwardButton").addEventListener("click", () => {
    let current = parseInt(slider.value);
    if (current < maxTurn) {
      slider.value = current + 1;
      updateTurn(parseInt(slider.value));
    }
  });

  document.getElementById("zoomInButton").addEventListener("click", () => {
    zoom *= 1.25;
    drawMap();
  });

  document.getElementById("zoomOutButton").addEventListener("click", () => {
    zoom /= 1.25;
    drawMap();
  });

  document.getElementById("resetViewButton").addEventListener("click", () => {
    zoom = 1.0;
    offsetX = 0;
    offsetY = 0;
    drawMap();
  });

  resizeCanvasToMapAspect();
  updateTurn(1);
}

function animateStep() {
  const {
    currentTurn,
    currentFrame,
    framesPerTurn
  } = animationSettings;

  const nextTurn = currentTurn + 1;
  const slider = document.getElementById("turnSlider");
  const max = parseInt(slider.max);

  const t = currentFrame / framesPerTurn;
  drawMap({ turn: currentTurn, nextTurn, t });

  animationSettings.currentFrame++;

  if (animationSettings.currentFrame < framesPerTurn) {
    animationFrameId = requestAnimationFrame(animateStep);
  } else {
    animationSettings.currentTurn++;
    slider.value = animationSettings.currentTurn;
    updateTurn(animationSettings.currentTurn); // update other UI

    if (animationSettings.currentTurn >= max) {
      togglePlayPause(); // Stop at last turn
    } else {
      animationSettings.currentFrame = 0;
      animationFrameId = requestAnimationFrame(animateStep);
    }
  }
}

function togglePlayPause() {
  const button = document.getElementById("playPauseButton");

  if (isPlaying) {
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
    isPlaying = false;
    button.textContent = "‚ñ∂Ô∏è";
  } else {
    isPlaying = true;
    button.textContent = "‚è∏Ô∏è";

    const slider = document.getElementById("turnSlider");
    animationSettings.currentTurn = parseInt(slider.value);
    animationSettings.currentFrame = 0;

    requestAnimationFrame(animateStep);
  }
}

function rewind() {
  const slider = document.getElementById("turnSlider");
  slider.value = 1;
  updateTurn(1);
  if (isPlaying) togglePlayPause(); // Stop playback if active
}

canvas.addEventListener("mousedown", (e) => {
  isDragging = true;
  dragStart = { x: e.clientX, y: e.clientY };
});

canvas.addEventListener("mouseup", () => {
  isDragging = false;
});

canvas.addEventListener("mouseleave", () => {
  isDragging = false;
});

canvas.addEventListener("mousemove", (e) => {
  if (isDragging) {
    const dx = e.clientX - dragStart.x;
    const dy = e.clientY - dragStart.y;
    dragStart = { x: e.clientX, y: e.clientY };
    offsetX += dx;
    offsetY += dy;
    drawMap();
  }
});

canvas.addEventListener("wheel", (e) => {
  event.preventDefault(); // prevent page scroll

  const rect = canvas.getBoundingClientRect();
  const mx = event.clientX - rect.left;
  const my = event.clientY - rect.top;

  // World coords before zoom
  const mapX = (mx - centerOffsetX - offsetX) / (baseScale * zoom) + bounds.left;
  const mapY = bounds.top - (my - centerOffsetY - offsetY) / (baseScale * zoom);

  const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1;
  zoom *= zoomFactor;

  // Recompute scale & center offsets
  const newScaled = baseScale * zoom;
  const newCenterOffsetX = (canvas.width - mapWidth * newScaled) / 2;
  const newCenterOffsetY = (canvas.height - mapHeight * newScaled) / 2;

  // Adjust pan so zoom focuses on mouse
  offsetX = mx - (mapX - bounds.left) * newScaled - newCenterOffsetX;
  offsetY = my - (bounds.top - mapY) * newScaled - newCenterOffsetY;

  centerOffsetX = newCenterOffsetX;
  centerOffsetY = newCenterOffsetY;

  drawMap();
}, { passive: false }); // notify browser that native scrolling will be disabled

</script>

</body>
</html>
